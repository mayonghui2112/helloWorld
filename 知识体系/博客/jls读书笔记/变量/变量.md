## 变量

变量是一个存储位置，有着特定的类型（基本数据类型或者引用类型），有时也叫做编译类型。

变量的只可以通过赋值语句= ，++，--等操作进行改变。

只要程序没有非检查警告信息，Java语言就能保证变量的值和它的类型的兼容性。默认值是兼容的，而且，变量的所有赋值操作都会检查他的兼容性。除了涉及到数组的情况外，所有兼容下检查都是在编译时进行的。

### 基本类型变量

基本类型变量的值是一个精确的基本数据类型的值。

### 引用类型的值

类T类型的变量的值可以是null，T的实例，T子类的实例。

接口T类型的变量的值可以是null，实现T的类的实例。

一个变量并不能保证一定指向声名类型的子类型，只能保证指向声名类型的子类或者子接口。这是因为可能的堆污染引起的。

T是基本数据类型，数组T类型的变量只能指向一个null，或者T类型的数组。

如果T是一个引用数据类型，数组T类型变量可以指向null，或者T/子类/子接口类型的数组。

Object[]类型变量可以指向null或者任何引用类型的数组。

Object类型变量可以指向null，或者任何对象的引用，无论它是一个类实例还是一个数组实例。

一个参数化类型变量指向一个非参数化类型的变量也是可以的，这种情况叫做堆污染（一种类型变量引用了另一种不兼容的类型实例）。以下情况会引起堆污染：

- 引起编译时未检查警告的raw type的操作	。

- 将一个非具体化类型的数组的值赋值给一个supertype(raw type或者非泛型）的数组类型变量。如下。

  ~~~java
  List l = new ArrayList<Number>();
  List<String> ls = l; // Unchecked warnin
  ~~~

  也产生一个编译时未检查的警告，因为无论是在编译时（在编译时类型检查规则的范围内）还是在运行时都无法确定变量l是否确实引用了List \<String>。

  上面的代码运行时，引起了堆污染，因为List\<String>类型变量 ls 引用了一个实际类型不是List\<String>的值。

  在运行时无法确定问题，因为类型变量是模糊泛型（reified），因此实例在运行时不携带任何有关用于创建变量的类型参数的信息。

- 数组类型的不安全的相互引用。

  ~~~java
  static void m(List<String>... stringLists) {
  Object[] array = stringLists;
  List<Integer> tmpList = Arrays.asList(42);
  array[0] = tmpList; // (1)
  String s = stringLists[0].get(0); // (2)
  }
  ~~~

  好的编程实践要求，无论发生了上面编程警告，程序都是正确且没有堆污染的。

### Kinds of Variables(变量的种类)

8种变量：

1. 类或接口的静态域变量。在类准备阶段创建并初始化一个默认值。
2. 类的实例变量。作为类及其子类创建的一部分，类的实例变量也会被创建并初始化一个默认值。
3. 数组的元素变量。当数组创建的时候，他的元素变量也被创建并赋予一个默认值。
4. 方法参数。方法被调用的时候创建。
5. 构造函数参数：
6. Lambda表达式参数。
7. catch语句块的异常参数。
8. 本地变量

### final变量

final修饰的变量，

如果类型是引用类型，变量指向的对象（也就是变量的值）不能改变，但是变量指向的对象的值可以改变。

如果类型是基本数据类型，他的值就是基本数据的类型的值，所以他是不变的。

特殊的，基本数据类型和String引用类型声名的final变量，如果它使用常量表达式初始化的，那么他就是一个常量。一个变量是否是一个常量变量可能会涉及到类初始化、二进制兼容性和明确的赋值。

以下三种变量被隐式的声名为final：

- 接口的变量
- try-with-resources种的资源变量
- 多catch块种的异常参数。（单cathc块没被final修饰，但实际上是final的）



## 参考文档

[JAVA泛型学习笔记](https://www.cnblogs.com/ShaneZhang/p/5043308.html)