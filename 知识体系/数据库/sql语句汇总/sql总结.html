
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="zh-CN" />
    <meta name="author" content="guolei" />
    <meta name="Copyright" content="Csdn" />
    <meta name="description" content="本人总结的SQL用法" />
    <meta name="keywords" content="guolei,本人总结的SQL用法" />
    <link rel="stylesheet" href="http://hi.images.csdn.net/css/main.css" type="text/css" media="all" />
    <script type="text/javascript" src="http://blog.csdn.net/script/feedBackToolTips.js"></script>
    <script type="text/javascript" src="http://blog.csdn.net/script/Tooltip/JSUtils.js"></script>
    <link type="text/css" rel="stylesheet" href="http://hi.images.csdn.net/css/syntaxhighlighter/SyntaxHighlighter.css" />
    
<link rel="Shortcut Icon" href="http://profile.csdn.net/guolei0451/picture/1.ico" />
    
<link href="http://hi.images.csdn.net/css/Cogitation/skinandwrap.css" type="text/css" rel="stylesheet" media="all" />
<link href="http://blog.csdn.net/guolei0451/rss.aspx" title="RSS" type="application/rss+xml" rel="alternate" />
    <title>本人总结的SQL用法 - 郭磊的专栏 - CSDNBlog</title>
</head>
<body id="defaultuser">
    <div id="csdnblog_allwrap">
        <form name="Form1" method="post" action="1217574.aspx" language="javascript" onsubmit="javascript:return WebForm_OnSubmit();" id="Form1">
<input type="hidden" name="__EVENTTARGET" id="__EVENTTARGET" value="" />
<input type="hidden" name="__EVENTARGUMENT" id="__EVENTARGUMENT" value="" />
<input type="hidden" name="__VIEWSTATE" id="
__VIEWSTATE" value="" />

<script type="text/javascript">
<!--
var theForm = document.forms['Form1'];
if (!theForm) {
    theForm = document.Form1;
}
function __doPostBack(eventTarget, eventArgument) {
    if (!theForm.onsubmit || (theForm.onsubmit() != false)) {
        theForm.__EVENTTARGET.value = eventTarget;
        theForm.__EVENTARGUMENT.value = eventArgument;
        theForm.submit();
    }
}
// -->
</script>


<script src="/WebResource.axd?d=vPBp1uwAXcWW_HR7kQLSJw2&amp;t=633368809778488179" type="text/javascript"></script>

<script type="text/javascript">
//<![CDATA[
var Anthem_FormID = "Form1";
//]]>
</script>
<script src="/WebResource.axd?d=xe4Hb-SpxzFzlneGulsvshD5tJaeoT5rOhxhNgNV4Rw1&amp;t=633221774454375000" type="text/javascript"></script>
<script src="/WebResource.axd?d=sCPKYj5Niyz0W_esyXefUe_mVagR4BQx1pHtu2ZkeZk1&amp;t=633368809778488179" type="text/javascript"></script>
<script type="text/javascript">
<!--
function WebForm_OnSubmit() {
if (typeof(ValidatorOnSubmit) == "function" && ValidatorOnSubmit() == false) return false;
return true;
}
// -->
</script>

        
<div id="csdnblog_midwrap">
    <div id="csdnblog_header">
        
        

<h1><a id="Header1_HeaderTitle" href="http://blog.csdn.net/guolei0451/">郭磊的专栏</a></h1>
<h2><span id="TopicAuthor" style="display: none">guolei0451</span></h2>


        
        <ul id="personalnav"><li><a href="http://hi.csdn.net/jackfor001" target="_blank">欢迎 jackfor001</a></li><li><a href="http://hi.csdn.net/Admin/MessageListInbox.aspx">我的首页<em></em></a></li><li><a href="http://writeblog.csdn.net/Signout.aspx">退出</a></li></ul>

        
        
<script type="text/javascript">
function checkNull()
{
    var searchScope = document.getElementById('Search_ddlSearchScope').value;
    var searchText = document.getElementById('Search_txtSearch').value;
    if(searchText!='')
    {
        var searchUri = "http://so.csdn.net/Default.aspx?q="+searchText;;
        if(searchScope != 'all')
            searchUri = searchUri + " username:"+searchScope;
            
        window.open(searchUri);
    }
    return false;
    
}
function keyb(evt)
{

    var eve = evt==null?window.event:evt;
    if (eve.keyCode==13) 
    {
         checkNull();
         return false;
     }
    else return true; 
}
</script>
<ul id="blogsearchsty">
    <li>
        <input name="Search:txtSearch" type="text" size="18" id="Search_txtSearch" class="bolgsearch" onkeydown="return keyb(event);" />
        
    </li>
    <li class="selectsty">
        <select name="Search:ddlSearchScope" id="Search_ddlSearchScope">
	<option value="all">全站</option>
	<option value="guolei0451">当前博客</option>

</select>
    </li>
    <li>
       
            <input type="button" id="btnSearch2" onclick="checkNull()" value="搜索" class="bolggobtn" />
</li>
</ul>

        
        <ul id="menu"><li><a href="http://hi.csdn.net/guolei0451">空间</a></li><li><a href="http://blog.csdn.net/guolei0451" class="on">博客</a></li><li><a href="http://hi.csdn.net/guolei0451/profile/contactlist/1.html">好友</a></li><li><a href="http://blog.csdn.net/guolei0451/Gallery.aspx">相册</a></li><li><a href="http://hi.csdn.net/guolei0451/profile/notebook/1.html" class="last">留言</a></li></ul>

    </div>
    <div id="csdnblog_sidebar">
        <div class="gutter">
            <div class="aboutauthor">
                <dl>
                    
                    <dt>
    郭磊<span>ID：guolei0451</span>
</dt>
<dd class="middle">
    <img src="http://profile.csdn.net/guolei0451/picture/1.jpg" alt="" />
</dd>
<dd class="middle">
    <a href="http://profile.csdn.net/8/E4/edit.html"></a>
</dd>
<dd>
    共<em>70176</em>次访问，排名<em>1280(5)</em>好友<em>0</em>人，关注者<em>0</em>人<br/>
</dd>
<dd>
  <a href="http://webim.csdn.net/AddFriends/guolei0451.ashx" target="_blank">[加为好友]</a> <a href="http://webim.csdn.net/Messages/guolei0451.ashx" target="_blank">[即时聊天]</a> <a href="http://hi.csdn.net/Admin/WriteMessage.aspx?Receiver=guolei0451" target="_blank">[发私信]</a>
</dd>
<dt>guolei0451的文章</dt>
<dd>原创 27 篇</dd>
<dd>翻译 0 篇</dd>
<dd>转载 85 篇</dd>
<dd>评论 14 篇</dd>
 
                    
                    

                    <span id="Anthem_RecentComments_ltlComments__"><span id="RecentComments_ltlComments"><dt>最近评论</dt><dd>hias_asia：<a href="http://blog.csdn.net/guolei0451/articles/1430884.aspx#775562" Title="点击查看《回复:为你的电脑系统清除所有垃圾只要30秒 》">ECHO C:\TB\TB.EXE /R+ &gt; C:\tb11.bat<br />ECHO C:\TC\BIN\tc.exe /R+ &gt; C:\tc30.bat<br />ECHO C:\TP\BIN\TPX.EXE /R+ &gt; C:\tp70.bat<br />ECHO 彻底卸载MSN Messager<br />RunDll32.exe advpack.dll,Laun……</a></dd><dd>hias_asia：<a href="http://blog.csdn.net/guolei0451/articles/1430884.aspx#775561" Title="点击查看《回复:为你的电脑系统清除所有垃圾只要30秒 》">Doskey CD...=CD..$tCD..<br />Doskey CD....=CD..$tCD..$tCD..<br />Doskey rarbg="C:\Program Files\WinRAR\WinRAR.exe" a -cu -ep1 -ibck $1<br />Doskey rarsm="C:\Program Files\WinRAR\WinRAR.exe" a -cl -……</a></dd><dd>hias_asia：<a href="http://blog.csdn.net/guolei0451/articles/1430884.aspx#775560" Title="点击查看《回复:为你的电脑系统清除所有垃圾只要30秒 》">ve.scr"<br />DEL "%systemroot%\system32\ss3dfo.scr"<br />DEL "%systemroot%\system32\ssbezier.scr"<br />DEL "%systemroot%\system32\ssflwbox.scr"<br />DEL "%systemroot%\system32\ssmarque.scr"<br />DE……</a></dd><dd>hias_asia：<a href="http://blog.csdn.net/guolei0451/articles/1430884.aspx#775559" Title="点击查看《回复:为你的电脑系统清除所有垃圾只要30秒 》">del /f /s /q %systemdrive%\*.log  <br />del /f /s /q %systemdrive%\*.gid  <br />del /f /s /q %systemdrive%\*.chk  <br />del /f /s /q %systemdrive%\*.old  <br />del /f /s /q %systemdrive%\recycled\*……</a></dd><dd>hias_asia：<a href="http://blog.csdn.net/guolei0451/articles/1430884.aspx#775558" Title="点击查看《回复:为你的电脑系统清除所有垃圾只要30秒 》">给楼主看看我的批处理文件版本<br />CLS<br />@echo off<br />ECHO.<br />ECHO 删除墙纸...<br />DEL "%systemroot%\Blue Lace 16.bmp"<br />DEL "%systemroot%\Coffee Bean.bmp"<br />DEL "%systemroot%\FeatherTexture.bmp"<br />……</a></dd></span></span>

                    
                    <dt>文章分类</dt><dd><div class="publiclist_sidebar"><ul><li><a href="http://blog.csdn.net/guolei0451/category/238491.aspx">C#(ADO.NET)</a><a href="http://blog.csdn.net/guolei0451/category/238491.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238500.aspx">C#(DATASET)</a><a href="http://blog.csdn.net/guolei0451/category/238500.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238501.aspx">C#(Socket)</a><a href="http://blog.csdn.net/guolei0451/category/238501.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238510.aspx">C#(TreeView)</a><a href="http://blog.csdn.net/guolei0451/category/238510.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238951.aspx">C#(其它)</a><a href="http://blog.csdn.net/guolei0451/category/238951.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238488.aspx">C#(托盘)</a><a href="http://blog.csdn.net/guolei0451/category/238488.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/195497.aspx">C#(线程)</a><a href="http://blog.csdn.net/guolei0451/category/195497.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238471.aspx">C#(消息)</a><a href="http://blog.csdn.net/guolei0451/category/238471.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238502.aspx">SQL SERVER</a><a href="http://blog.csdn.net/guolei0451/category/238502.aspx/rss">(RSS)</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238929.aspx">打包</a><a href="http://blog.csdn.net/guolei0451/category/238929.aspx/rss">(RSS)</a></li></ul></div></dd><dt>收藏</dt><dd><div class="publiclist_sidebar"><ul><li><a href="http://blog.csdn.net/guolei0451/category/244292.aspx">ASP.NET（学习资料）</a></li><li><a href="http://blog.csdn.net/guolei0451/category/244298.aspx">成功人生</a></li><li><a href="http://blog.csdn.net/guolei0451/category/250671.aspx">基础理论</a></li><li><a href="http://blog.csdn.net/guolei0451/category/250649.aspx">色彩</a></li><li><a href="http://blog.csdn.net/guolei0451/category/238570.aspx">系统维护</a></li><li><a href="http://blog.csdn.net/guolei0451/category/244294.aspx">项目管理</a></li></ul></div></dd><dt>相册</dt><dt>C#</dt><dd><a href="http://blog.csdn.net/ChengKing/" target="_blank">ChengKing(ZhengJian)有游戏代码</a></dd><dd><a href="http://www.codeproject.com/" target="_blank">CODEPROJECT</a></dd><dd><a href="http://www.syncfusion.com/faq/aspnet/default.aspx" target="_blank">FAQ/ASPNET</a></dd><dd><a href="http://www.syncfusion.com/FAQ/WindowsForms/" target="_blank">FAQ/WindowsForms</a></dd><dd><a href="http://blog.csdn.net/haibodotnet/" target="_blank">haibodotnet水晶报表</a></dd><dd><a href="http://www.cnblogs.com/Pierce/" target="_self">Pierce BLOG 中的NetWork 有关于socket的知识</a></dd><dd><a href="http://blog.csdn.net/Knight94/" target="_blank">愚翁专栏</a></dd><dd><a href="http://www.lijianzhong.com/" target="_blank">李建忠</a></dd><dd><a href="http://blog.csdn.net/zjcxc/" target="_blank">邹建专栏</a></dd><dd><a href="http://www.chenjiliang.com/" target="_blank">阿良.NET</a></dd><dt>SharePoint </dt><dd><a href="http://blog.joycode.com/choral/" target="_blank">SharePoint </a></dd><dt>电子图书</dt><dd><a href="http://www.gy16.com/" target="_blank">公益电子书</a></dd><dt>好友BLOG</dt><dd><a href="http://blog.sina.com.cn/u/1216773771" target="_blank">康健</a></dd><dd><a href="http://wonderfulhongli.spaces.live.com/" target="_blank">都都</a></dd><dt>软件资源</dt><dd><a href="http://www.qiqi.org/down/index.php" target="_blank">QIQI资源</a></dd><dt>存档</dt><dd><div class="publiclist_sidebar"><ul><li><a href="/guolei0451/archive/2007/01.aspx">2007年01月(1)</a></li><li><a href="/guolei0451/archive/2006/12.aspx">2006年12月(1)</a></li><li><a href="/guolei0451/archive/2006/11.aspx">2006年11月(11)</a></li><li><a href="/guolei0451/archive/2006/10.aspx">2006年10月(22)</a></li><li><a href="/guolei0451/archive/2006/09.aspx">2006年09月(52)</a></li></ul></div></dd>

                    <span id="RecentVisitors"></span>
                    
                    <dt>软件项目交易</dt><dd><iframe style="margin:0;　padding:0; width: 180px; height: 32px;" src="http://prj.csdn.net/CSDN/CsdnBlog/CsdnBlogPage.html" frameborder="0" scrolling="no" ></iframe></dd>
                    
                    <span id="SubscriptionList"><dt>订阅我的博客</dt><dd><a href="http://blog.csdn.net/guolei0451/Rss.aspx" ><img border="0" alt="XML聚合" src="/images/xml.gif" /></a>&nbsp;&nbsp;<a href="http://feeds.feedsky.com/csdn.net/guolei0451" target="_blank"><img border="0" alt="FeedSky" src="/images/feedsky.gif" /></a></dd><dd><a href="http://www.xianguo.com/subscribe.php?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到鲜果" src="/images/rss_xianguo.jpg"/></a></dd><dd><a href="http://fusion.google.com/add?feedurl=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到Google" src="/images/rss_google.gif"/></a></dd><dd><a href="http://www.zhuaxia.com/add_channel.php?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到抓虾" src="/images/rss_zhuaxia.gif"/></a></dd><dd><a href="http://www.bloglines.com/sub/http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到BlogLines" src="/images/rss_bloglines.gif"/></a></dd><dd><a href="http://add.my.yahoo.com/rss?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到Yahoo" src="/images/rss_yahoo.gif"/></a></dd><dd><a href="http://rss.gougou.com/find_rss.jsp?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到GouGou" src="/images/rss_gougou.gif"/></a></dd><dd><a href="http://www.pageflakes.com/subscribe.aspx?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到飞鸽" src="/images/rss_pageflakes.gif"/></a></dd><dd><a href="http://www.rojo.com/add-subscription?resource=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到Rojo" src="/images/rss_rojo.gif"/></a></dd><dd><a href="http://www.newsgator.com/ngs/subscriber/subfext.aspx?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到newsgator" src="/images/rss_newsgator.gif"/></a></dd><dd><a href="http://www.netvibes.com/subscribe.php?url=http://blog.csdn.net/guolei0451/Rss.aspx" target="_blank"><img border="0" alt="订阅到netvibes" src="/images/rss_netvibes.gif"/></a></dd></span>
                </dl>
            </div>
        </div>
    </div>
    
    <div id="csdnblog_content">
        <div class="gutter">
            
           
<div class="default_contents">
    <div class="user_article">

        <script type="text/javascript" src="http://blog.csdn.net/js/LoadFeedbackCount.js"></script>

        

<style type="text/css">
    cite.fav_csdnstylebykimi
    {
        font-style: normal;
        margin: 0 0 0 5px;
        display: inline;
        text-decoration: none;
        padding: 0;
    }
    cite.fav_csdnstylebykimi a
    {
        font: normal 12px Tahoma,sans-serif;
        padding: 0 25px 1px 10px;
        background: url(http://newcsdn.csdn.net/images/share-add.gif) 0 0 no-repeat;
    }
    * + html cite.fav_csdnstylebykimi a
    {
        padding: 2px 25px 0 10px !important;
    }
    @media all and (min-width:0px)
    {
        cite.fav_csdnstylebykimi a
        {
            padding: 1px 25px 1px 10px;
        }
    }
    cite.fav_csdnstylebykimi a:hover
    {
        background: url(http://newcsdn.csdn.net/images/share-add.gif) 0 100% no-repeat;
        color: #fff;
        text-decoration: none;
        clear: both;
    }
</style>
<h1><img src="/images/authorship.gif" border="0" width="15" height="16" alt="原创" />&nbsp;<a href="http://blog.csdn.net/guolei0451/archive/2006/09/13/1217574.aspx">本人总结的SQL用法</a><cite class="fav_csdnstylebykimi"><a href="JavaScript:d=document;t=d.selection?(d.selection.type!='None'?d.selection.createRange().text:''):(d.getSelection?d.getSelection():'');void(saveit=window.open('http://wz.csdn.net/storeit.aspx?t='+escape(d.title)+'&u='+escape(d.location.href)+'&c='+escape(t),'saveit','scrollbars=no,width=590,height=300,left=75,top=20,status=no,resizable=yes'));saveit.focus();" class="fav_csdnstylebykimi" title="收藏到我的网摘中，并分享给我的朋友">收藏</a></cite></h1>
<div class="blogstory">
<span id="Post.ascx_ViewPost_PreviousAndNextEntriesUp"><h3><a href="http://blog.csdn.net/guolei0451/archive/2006/09/13/1217587.aspx">新一篇:&nbsp;日志文件太大的解决办法</a></h3></span>
    <script>function StorePage(){d=document;t=d.selection?(d.selection.type!='None'?d.selection.createRange().text:''):(d.getSelection?d.getSelection():'');void(keyit=window.open('http://www.365key.com/storeit.aspx?t='+escape(d.title)+'&u='+escape(d.location.href)+'&c='+escape(t),'keyit','scrollbars=no,width=475,height=575,left=75,top=20,status=no,resizable=yes'));keyit.focus();}</script><p>SELECT @@SERVERNAME&nbsp; 结果：guolei<br />=============================================================================================================================<br />选择出重复的字段<br />SELECT id<br />FROM [temp]<br />WHERE (SELECT COUNT(*)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM (SELECT *<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM TEMP) AS aa<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE aa.id = TEMP .id) &gt; 1</p>
<p>INSERT INTO temp1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (id, SUM) (SELECT ziduan1, SUM(ziduan2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM TEMP<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP BY ziduan1)</p>
<p>选择出重复的字段<br />SELECT id<br />FROM [temp]<br />WHERE (SELECT COUNT(*)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM (SELECT *<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM TEMP) AS aa<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE aa.id = TEMP .id) &gt; 1<br />SELECT *, COUNT(*) AS 重复记录数<br />FROM [temp]<br />GROUP BY ziduan1, ziduan2</p>
<p>WITH temp(...,...) AS<br />(<br />&nbsp; select ...<br />)<br />select ... from temp<br />group by ..<br />having ...<br />with子句中的select用来返回一系列结果<br />存放在临时表temp中<br />后一个Select从temp中取出数据分组。<br />此语句只能在大型数据库中使用。</p>
<p>有两个意义上的重复记录，一是完全重复的记录，也即所有字段均重复的记录，二是部分关键字段重复的记录，比如Name字段重复，而其他字段不一定重复或都重复可以忽略。<br />1、对于第一种重复，比较容易解决，使用<br />&nbsp;&nbsp;&nbsp; select distinct * from tableName<br />就可以得到无重复记录的结果集。<br />如果该表需要删除重复的记录（重复记录保留1条），可以按以下方法删除<br />&nbsp;&nbsp;&nbsp; select distinct * into #Tmp from tableName<br />&nbsp;&nbsp;&nbsp; drop table tableName<br />&nbsp;&nbsp;&nbsp; select * into tableName from #Tmp<br />&nbsp;&nbsp;&nbsp; drop table #Tmp<br />发生这种重复的原因是表设计不周产生的，增加唯一索引列即可解决。</p>
<p>2、这类重复问题通常要求保留重复记录中的第一条记录，操作方法如下<br />&nbsp;&nbsp;&nbsp; 假设有重复的字段为Name,Address，要求得到这两个字段唯一的结果集<br />&nbsp;&nbsp;&nbsp; select identity(int,1,1) as autoID, * into #Tmp from tableName<br />&nbsp;&nbsp;&nbsp; select min(autoID) as autoID into #Tmp2 from #Tmp group by Name,autoID<br />&nbsp;&nbsp;&nbsp; select * from #Tmp where autoID in(select autoID from #tmp2)<br />&nbsp;&nbsp;&nbsp; 最后一个select即得到了Name，Address不重复的结果集（但多了一个autoID字段，实际写时可以写在select子句中省去此列）</p>
<p>identity的用法<br />SELECT IDENTITY(int, 1,1) AS ID_Num,*<br />INTO NewTable<br />FROM OldTable<br />把OldTable的全部内容加入到新表NewTable中的去,并在NewTable加一字段ID_NUM.</p>
<p>/////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>1.把某个字段重新生气序列(从1到n): <br />DECLARE @i int <br />Set @i = 0 <br />Update Table1 Set @i = @i + 1,Field1 = @i <br /><br />2.按成绩排名次 <br />Update 成绩表 <br />Set a.名次 = ( <br />Select Count(*) + 1 <br />From 成绩表 b <br />Where a.总成绩 &lt; b.总成绩 <br />) <br />From 成绩表 a <br /><br />3.查询外部数据库 <br />Select a.* <br />From OpenRowSet('Microsoft.Jet.OLEDB.4.0','c:\test.mdb';'admin';'',Table1) a <br /><br />4.查询Excel文件 <br />Select * <br />From OpenDataSource('Microsoft.Jet.OLEDB.4.0','Data Source=&quot;c:\test.xls&quot;;User ID=Admin;Password=;Extended properties=Excel 8.0')...Sheet1$ <br /><br />5.在查询中指定排序规则 <br />Select * From Table1 Order By Field1 COLLATE Chinese_PRC_BIN <br />为什么要指定排序规则呢?参见: <br />http://www.delphibbs.com/delphibbs/dispq.asp?lid=1633985 <br />例,检查数据库中的Pub_Users表中是否存在指定的用户: <br />Select Count(*) From Pub_Users Where [UserName]='admin' And [PassWord]='aaa' COLLATE Chinese_PRC_BIN <br />默认比较是不区分大小写的,如果不加COLLATE Chinese_PRC_BIN,那么密码aaa与AAA是等效的,这当然与实际不符.注意的是,每个条件都要指定排序规则,上例中用户名就不区分大小写. <br /><br /><br />6.Order By的一个小技巧 <br />Order By可以指定列序而不用指定列名,在下面的例子里说明它的用处(注意,第三列未指定别名) <br />Select a.ID,a.Name,(Select Count(*) From TableB b Where a.ID=b.PID) From TableA a Order By 3&nbsp;<br />&nbsp;<br />//////////////////////////////////////////////////////////////////////////////////////////列转行<br />SELECT Size_Class, MAX(CASE WHEN DisplayIndex = 1 THEN Size1 END) AS S1, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX(CASE WHEN DisplayIndex = 2 THEN Size1 END) AS S2, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX(CASE WHEN DisplayIndex = 3 THEN Size1 END) AS S3, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX(CASE WHEN DisplayIndex = 4 THEN Size1 END) AS S4<br />FROM Table1<br />GROUP BY Size_Class<br />///////////////////////////////////////////////////////////////////////////<br />SELECT *<br />FROM Sys_Account<br />WHERE (ATID LIKE '[1-2]%')<br />///////////////////////////////////////////////////////////////////////////<br />延迟查询<br />str:= 'waitfor delay '''+MaskEdit1.Text+'''Select * From sys_account where aid=''范玉成''';<br />按照时间查询 <br />str:= 'waitfor time '''+timetostr(DateTimePicker1.Time)+'''Select * From sys_account where aid=''范玉成''';<br />///////////////////////////////////////////////////////////<br />truncate table_name ----------- 删除表中所有行，仍保持表的完整性<br />drop table table_name --------------- 完全删除表<br />///////////////////////////////////////////////////////////////////////////<br />adoconnetcion.execute('insert into 表1 select * from 表2 in &quot;c:\xxx.mdb&quot;')</p>
<p>其中adoconnetcion连接你的第一个access数据库，xxx.mdb是你的第二个数据库 <br />////////////////////////////////////////////////////////////////////////////////////////////<br />INSERT INTO 表B(字段1,字段2.....) <br />&nbsp; SELECT 对应字段1,对应字段2....<br />&nbsp; WHERE 关键字 NOT IN (SELECT 表B.关键字 FROM 表B)<br />////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br />想同时对三个字段进行定位查找，但只输入一个参数值，用Locate可以实现吗？<br />用循环法给Locate赋值,找到就退出. <br />如:A:Array[1..3] of string=('字段1','字段2','字段3'); <br />for i:=1 to 3 do <br />ADOTable1.Locate(''+A[1]+'','参数',[]);// <br />如果找到就break<br />=============================================================================================================================backup log [Hpcc3OA] with no_log dbcc shrinkdatabase('Hpcc3OA',truncateonly)<br />=============================================================================================================================<br />UPDATE Sys_Account<br />SET AID = REPLACE(AID, '真', '于') <br />将字段AID中含有'真'的字符替换成'于'<br />=========================================================================================================================<br />在SQL中判断某日是星期几<br />SELECT DATENAME (WEEKDAY,'2006-03-14')<br />此示例从 GETDATE 返回的日期中提取月份名<br />SELECT DATENAME(month, getdate()) AS 'Month Name'<br />SELECT DATEPART(month, GETDATE())<br />=========================================================================================================================<br />根据出生年月日算出生肖</p>
<p>declare @dt as datetime<br />set @dt = '1981 -01-01'<br />select case when year(@dt)%12 = 0 then '猴' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 1 then '鸡'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 2 then '狗'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 3 then '猪'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 4 then '鼠'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 5 then '牛'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 6 then '虎'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 7 then '兔'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 8 then '龙'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 9 then '蛇'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 10 then '马'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when year(@dt)%12 = 11 then '羊'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end as 生肖</p>
<p>////////////////////////////////////////////////////////////////////////////////////////<br />如果Query控件用Open方法执行SQL语句，并且所用的SQL语句访问的是一张或几张频繁使用的表，在执行完SQL语句后，一定要调用SQL的FetchAll方法，能大大地减少死锁发生的概率。例如：<br />&nbsp; Query1.Close;<br />&nbsp; Query1.SQL.Clear;<br />&nbsp; Query1.SQL.Add('select * from&nbsp; AA');<br />&nbsp; Query1.Open;<br />&nbsp; Query1.FetchAll;</p>
<p>在上述的例子中，如果AA是一张被频繁访问的表，在对这个表执行这一条select语句的同时，如果恰好有其他人对这张表执行删除或更新操作，便有可能发生死锁。Query1.FetchAll这条语句实现的功能是释放加在表AA上的锁，这样死锁的发生概率可以大大减少。避免死锁，对我们将来进行大型数据库开发尤为重要。<br />、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、////////////////</p>
<p>有sites表数据如下 <br />&nbsp;bh&nbsp;&nbsp;&nbsp;&nbsp; name <br />&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; A <br />&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; A <br />&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; B <br />&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; C <br />&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; C <br />&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; C <br />&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; D <br />&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; F <br />我想得到的统计结果是 <br />bh&nbsp;&nbsp; namecount <br />1&nbsp;&nbsp;&nbsp; 2 <br />2&nbsp;&nbsp;&nbsp; 3</p>
<p>select distinct bh, count(distinct name) from sites group by bh <br />SELECT bh,count(*) from <br />(select distinct bh,name from sites) <br />group by bh<br />////////////////////////////////////////////////////////////////////////////////////////////<br />Query1.SQL.Text:='select * from sys_account where atid=1';<br />Query1.Open;<br />=============================================================================================================================<br />表A(消费表)，表B(还款表)： <br />　　　　　　A <br />------------------------------------------- <br />客户　　日　　期　　消费金额 <br />甲　　　2000-1-1　　100 <br />乙　　　2000-2-2　　200 <br />丙　　　2000-2-3　　300 <br />丁　　　2000-3-2　　400 <br />甲　　　2000-3-5　　500 <br />乙　　　2000-3-6　　600 <br />　　　　　　B <br />------------------------------------------- <br />客户　　日　　期　　还款金额 <br />甲　　　2000-1-1　　100 <br />乙　　　2000-2-2　　300 <br />丙　　　2000-2-3　　100 <br />甲　　　2000-3-5　　200 <br />求查询语句，得到每个客户欠款余额，如下： <br />------------------------------------------- <br />客户　　欠款余额 <br />甲　　　　300 <br />乙　　&nbsp; 　500 <br />丙　　　&nbsp; 200 <br />丁　　　　400 <br />SELECT 客户, SUM(tmp) AS 欠款余额<br />FROM (SELECT 客户, 消费金额 AS tmp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM A<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION ALL<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT 客户, - 还款金额<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM B) DERIVEDTBL<br />GROUP BY 客户</p>
<p>((((ISNULL<br />使用指定的替换值替换 NULL。<br />下面的示例查找所有书的平均价格，用值 $10.00 替换 titles 表的 price 列中的所有 NULL 条目。<br />USE pubs<br />GO<br />SELECT AVG(ISNULL(price, $10.00))<br />FROM titles<br />GO))))</p>
<p>&nbsp;</p>
<p>=============================================================================================================================<br />id&nbsp; 电话 <br />1&nbsp;&nbsp; 123456 <br />2&nbsp;&nbsp; 0427-13150886560 <br />3&nbsp;&nbsp; 0427-7867065<br />我的这个表里的电话字段有的人写的是汉字，我想查出电话字段里写的是汉字的记录。这样的sql语句怎么写呢？<br />UniCode() <br />SELECT * FROM 表 WHERE UniCode(电话)&gt;255<br />=============================================================================================================================<br />我现在有个表字段和数据如下： <br />&nbsp; X1&nbsp;&nbsp; A&nbsp; B <br />&nbsp; 1&nbsp;&nbsp;&nbsp; 23 34 <br />&nbsp; 2&nbsp;&nbsp;&nbsp; 34 22 <br />&nbsp; 3&nbsp;&nbsp;&nbsp; 46 89 <br />想得到如下结果，就是增加一列，这一列为前两个值中最大的那个 <br />&nbsp;X1&nbsp;&nbsp; A&nbsp;&nbsp; B&nbsp;&nbsp; C(为前面两个中大的组成) <br />&nbsp;1&nbsp;&nbsp;&nbsp; 23&nbsp; 34&nbsp; 34 <br />&nbsp; 2&nbsp;&nbsp; 34&nbsp; 22&nbsp; 34 <br />&nbsp; 3&nbsp;&nbsp; 46&nbsp; 89&nbsp; 89 <br />用SQL如何写？<br />SELECT atid, did, (CASE WHEN atid &gt; did THEN atid ELSE did END) AS kkk<br />FROM Sys_Account<br />=============================================================================================================================<br />ADOConnection1.BeginTrans;<br />ADOConnection1.CommitTrans;<br />ADOConnection1.RollbackTrans;<br />Database1.StartTransaction;<br />Database1.Commit;<br />Database1.Rollback;事务<br />还是让SQL SERVER自己控制他的事务的好，你把语句写在<br />QUERY。SQL。ADD（&lsquo;begin Tran&rsquo;）<br />.......<br />.......<br />Query.sql.add('commit') ;<br />这样的提交很稳定，让数据库自己去处理事务要比DELPHI好，再有<br />如果你的应用程序死了的话呢，如果你ADO控制事务的话，那么SQL<br />语句不会回滚的，数据库自己去处理事务的会回滚，不信你自己去试<br />&nbsp; if&nbsp;&nbsp; Database1.InTransaction&nbsp; then&nbsp; //InTransaction is True if a transaction is in progress, False otherwise.<br />&nbsp; begin<br />&nbsp; end;<br />&nbsp; Query1.Connection.BeginTrans;<br />&nbsp; Query1.Connection.CommitTrans;<br />&nbsp; Query1.Connection.RollbackTrans;<br />TdataBase有个方法 StartTransaction ，调用后，进入显式事务，在调用前，用<br />TdataBase的InTransaction属性 Check一下是否有正在进行的事务，如果没有，则调用<br />starttransaction开始一个新事务，事务只到调用commit 或 rollback 结束，否则<br />又开始一个新事务就会产生异常，这是显式事务。如果不显式调用Tdatabaes的<br />starttransaction，则Delphi用隐式事务控制数据，隐式事务在Delphi中用得极为<br />普遍，Table的 Delete Post 都是在隐式事务的控制下，（前提是没有调用Tdatabase<br />的starttransaction〕，因此，post之后，Sql server是一定会有数据的，否则要么是<br />程序写错了，要么是盗自版软件，如果是Sql server的问题，那你就发大财了，可以向<br />微软起诉，我做了那么多程序，二层的程序用显式事务是不多的，三层的其实也不多，<br />因为大部分工作都能在隐式事务下很好的完成，除非写大型的而且逻辑相当复杂的<br />程序，为了取得较好性能，以及不使用显式事务就完成不了业务逻辑的情况下才使用，<br />然而，程序相对来说就难写了，老板要是不加薪，最好还是隐式事务算了。<br />各位老兄老弟，多看看帮助吧。<br />////////////////////////////////////////////////////////////////////////////////////////////<br />标题: 二个表同步更新SQL <br />--Error<br />update cusotmer001 set col001 = ( select col001 from cusotmer002<br />&nbsp;&nbsp; where cusotmer001.col001 = cusotmer002.col002) </p>
<p>--Right<br />update cusotmer001 set cusotmer001.col001 = b.col001<br />&nbsp;from cusotmer002 as b<br />&nbsp;where cusotmer001.col001 = b.col002<br />///////////////////////////////////////////////////////////////////////////////////////<br />==================================================================<br />&nbsp;ADOQuery1.SQL.Text := 'Select * from 表 ';<br />&nbsp;&nbsp;&nbsp; ADOQuery1.Open;<br />&nbsp;&nbsp;&nbsp; ADOQuery1.GetFieldNames(ComboBox1.Items); //all字段名<br />得到所有字段名。<br />================================================================== <br />在ＳＱＬ语句中字段名含有括号时解决方法 <br />例如：一个表aa中字段名为&ldquo;姓名(cName)&rdquo;&ldquo;金额(iQuantity)，则在查询时，就写为：<br />select [姓名(cName)]　from aa<br />select sum([金额(iQuantity)]) from aa</p>
<p>也就是在字段名前后加上[]即可。</p>
<p>=====================================================================<br />预先定义一个表 <br />ID&nbsp;&nbsp; cdefine1 <br />1&nbsp;&nbsp;&nbsp;&nbsp; aa <br />2&nbsp;&nbsp;&nbsp;&nbsp; ab <br />3&nbsp;&nbsp;&nbsp;&nbsp; bd <br />4&nbsp;&nbsp;&nbsp;&nbsp; bb <br />我需要通过Sql语句找出字段cdefine1的值在字符串aabbcc中有子串的记录 ？<br />slect ID,cdefine1 from tablename where charindex(cddefine1,'aabbcc',0)&gt;0 <br />CHARINDEX <br />返回字符串中指定表达式的起始位置。 <br />语法 <br />CHARINDEX ( expression1 , expression2 [ , start_location ] ) <br />参数 <br />expression1 <br />一个表达式，其中包含要寻找的字符的次序。expression1 是一个短字符数据类型分类的表达式。 <br />expression2 <br />一个表达式，通常是一个用于搜索指定序列的列。expression2 属于字符串数据类型分类。 <br />start_location <br />在 expression2 中搜索 expression1 时的起始字符位置。如果没有给定 start_location，而是一个负数或零，则将从 expression2 的起始位置开始搜索。 <br />返回类型 <br />int <br />注释 <br />如果 expression1 或 expression2 之一属于 Unicode 数据类型（nvarchar 或 nchar）而另一个不属于，则将另一个转换为 Unicode 数据类型。 <br />如果 expression1 或 expression2 之一为 NULL 值，则当数据库兼容级别为 70 或更大时，CHARINDEX 返回 NULL 值。当数据库兼容级别为 65 或更小时，CHARINDEX 仅在 expression1 和 expression2 都为 NULL 时返回 NULL 值。 <br />如果在 expression2 内没有找到 expression1，则 CHARINDEX 返回 0。</p>
<p>=============================================================================================================================<br />SET STATISTICS TIME ON<br />SET STATISTICS IO&nbsp; ON <br />select * from sys_account where atid='2'<br />在消息页面里结果为：<br />表 'Sys_Account'。扫描计数 1，逻辑读 3 次，物理读 0 次，预读 0 次。<br />SQL Server 执行时间: <br />&nbsp;&nbsp; CPU 时间 = 2 毫秒，耗费时间 = 2 毫秒。</p>
<p>SQL Server 执行时间: <br />&nbsp;&nbsp; CPU 时间 = 10 毫秒，耗费时间 = 9 毫秒。<br />SQL Server 执行时间: <br />&nbsp;&nbsp; CPU 时间 = 10 毫秒，耗费时间 = 10 毫秒。<br />SQL Server 分析和编译时间: <br />&nbsp;&nbsp; CPU 时间 = 0 毫秒，耗费时间 = 0 毫秒。<br />SQL Server 执行时间: <br />&nbsp;&nbsp; CPU 时间 = 0 毫秒，耗费时间 = 0 毫秒。</p>
<p>Set statistics IO<br />显示磁盘活动信息。此信息包括为查询所在使用的表名称，执行扫描的次数，从数据高速缓存和磁盘读取的页数，以及写入高速缓存的页数。默认设置为 OFF。<br />&nbsp;Set statistics IO ON 在查询分析器执行查询的时候就可以得到IO磁盘读写等数据<br />=============================================================================================================================<br />是这样的，比如我想查找A表中PersonName字段值为 Jame's Bond 的记录， <br />SELECT * <br />FROM A <br />WHERE PersonName = 'Jame's Bond' </p>
<p>问题就出在这儿：SQL语句中的字符串需要用单引号括起来，但如果这个字符串本身就包含了单引号，怎么办？ <br />望各位赐教<br />SELECT * <br />FROM A <br />WHERE PersonName = 'Jame''s Bond'&nbsp; //SQL SERVER 中的SQL中的写法</p>
<p>str:='SELECT * FROM Sys_Account WHERE AID =''tom''+''''''''+''s''';&nbsp; //在DELPHI中的写法<br />Query1.Close;<br />Query1.SQL.Clear;<br />Query1.SQL.Add(str);<br />Query1.Open;<br />=====================================================================<br />怎么能一条一条地取出一个数据库中所有的表名 用游标吧；<br />declare @tableName nvarchar(128)</p>
<p>declare myCursor cursor for <br />select [name] from sysobjects where xtype = 'U' </p>
<p>open myCursor</p>
<p>fetch next from mycursor into @TableName</p>
<p>while @@Fetch_Status = 0 <br />begin<br />&nbsp; print @TableName</p>
<p>&nbsp; fetch next from mycursor into @TableName<br />end</p>
<p>close mycursor<br />deallocate mycursor<br />=====================================================================<br />用ADOQuery1调用SQLServer的存储过程，怎么取回返回值 <br />存储过程如下： <br />CREATE PROCEDURE dt_Test <br />&nbsp;&nbsp; (@aa varchar(2000), @bb varchar(2000) OUTPUT) <br />&nbsp;&nbsp; AS <br />&nbsp;&nbsp; BEGIN <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .... <br />&nbsp;&nbsp; END </p>
<p>调用如下： <br />var <br />str: string; <br />begin <br />&nbsp;&nbsp; adoq.Close; <br />&nbsp;&nbsp; adoq.SQL.Clear; <br />&nbsp;&nbsp; adoq.SQL.Add('Execute dt_Test ' + QuotedStr('adfad') + ', :Results'); <br />&nbsp;&nbsp; adoq.Parameters.ParamByName('Results').DataType := ftString; <br />&nbsp;&nbsp; adoq.Prepared; <br />&nbsp;&nbsp; adoq.ExecSQL; <br />&nbsp;&nbsp; str := adoq.Parameters.ParamByName('Results').Value; <br />end; </p>
<p>提示类型转换错误。 </p>
<p>大家给个方法怎么取得返回值，谢谢了！！<br />=====================================================================</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>CREATE PROCEDURE Pro_ReturnDateTime<br />@ServerDate datetime output<br />AS<br />set @ServerDate=getDate() <br />GO<br />/*<br />**设置用户计算机信息<br />*/</p>
<p>CREATE proc Pro_SetComputerInfo <br />&nbsp; @AID varchar(20),<br />&nbsp; @ComputerName char(40),<br />&nbsp; @ComputerIP char(23),<br />&nbsp; @LogName char(20),<br />&nbsp; @ComputerComment varchar(1)=null <br />as<br />declare @RecoCount int<br />&nbsp; if exists (select ComputerName from Sys_Computer where <a href="mailto:computerName=@ComputerName">computerName=@ComputerName</a>)&nbsp; <br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; update Sys_Computer <br />&nbsp;&nbsp;&nbsp; set <a href="mailto:AID=@AID,ComputerName=@ComputerName,ComputerIP=@ComputerIP">AID=@AID,ComputerName=@ComputerName,ComputerIP=@ComputerIP</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="mailto:LogName=@LogName,Status=1">LogName=@LogName,Status=1</a><br />&nbsp;&nbsp;&nbsp; where <a href="mailto:ComputerName=@computerName">ComputerName=@computerName</a>&nbsp; <br />&nbsp; end<br />&nbsp; else<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; select @RecoCount=max(CID) from Sys_Computer<br />&nbsp;&nbsp;&nbsp; insert Sys_Computer(CID,AID,ComputerName,ComputerIP,LogName,Status)<br />&nbsp;&nbsp;&nbsp; values(@RecoCount+1,@AID,@ComputerName,@ComputerIP,@LogName,1)<br />&nbsp; end<br />GO<br />sgAID<br />&nbsp; end<br />&nbsp; CLOSE find1<br />&nbsp; DEALLOCATE find1</p>
<p>/**********************检查收文待承办消息***********************/<br />declare find2 CURSOR FOR /*游标 用于轮循结果集*/</p>
<p>&nbsp; select DAID,AID from DocAcceptCheck where YesOrNo=2<br />&nbsp; open find2<br />&nbsp; FETCH NEXT From find2<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set YesOrNo=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a><br />&nbsp;&nbsp;&nbsp; <br />&nbsp; FETCH NEXT FROM find2<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find2<br />&nbsp; DEALLOCATE find2</p>
<p>/**********************检查发文待批阅消息***********************/<br />declare find3 CURSOR FOR /*游标 用于轮循结果集*/</p>
<p>&nbsp; select DDID,AID from DocDispatchPostil where YesOrNo=2<br />&nbsp; open find3<br />&nbsp; FETCH NEXT From find3<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set YesOrNo=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a><br />&nbsp;&nbsp;&nbsp; <br />&nbsp; FETCH NEXT FROM find3<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find3<br />&nbsp; DEALLOCATE find3</p>
<p>/**********************检查发文待承办消息***********************/<br />declare find4 CURSOR FOR /*游标 用于轮循结果集*/</p>
<p>&nbsp; select DDID,AID from DocDispatchSend where YesOrNo=2<br />&nbsp; open find4<br />&nbsp; FETCH NEXT From find4<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set YesOrNo=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a><br />&nbsp;&nbsp;&nbsp; <br />&nbsp; FETCH NEXT FROM find4<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find4<br />&nbsp; DEALLOCATE find4</p>
<p>/**********************检查部门工作计划消息***********************/<br />declare find5 CURSOR FOR /*游标 用于轮循结果集*/</p>
<p>&nbsp; select PID,LID from DepartmentProjectBase where Status=2<br />&nbsp; open find5<br />&nbsp; FETCH NEXT From find5<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set YesOrNo=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a><br />&nbsp;&nbsp;&nbsp; <br />&nbsp; FETCH NEXT FROM find5<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find5<br />&nbsp; DEALLOCATE find5</p>
<p>/**********************检查会议通知***********************/<br />declare find6 CURSOR FOR /*游标 用于轮循结果集*/</p>
<p>&nbsp; select MID,AID from MeetingNotify where Status=1<br />&nbsp; open find6<br />&nbsp; FETCH NEXT From find6<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set YesOrNo=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a><br />&nbsp;&nbsp;&nbsp; <br />&nbsp; FETCH NEXT FROM find6<br />&nbsp; INTO @MsgValue,@MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find6<br />&nbsp; DEALLOCATE find6<br />GO<br />相关 and 收文号与要添加的收文号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=1 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @MsgContent=Title from DocAcceptBase where <a href="mailto:DAID=@MsgValue">DAID=@MsgValue</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='主题为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的收文需要您批阅.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find1<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find1<br />&nbsp; DEALLOCATE find1</p>
<p>declare find2 CURSOR FOR /*游标 用于轮循结果集*/<br />&nbsp; /****************检索收文待承办表*************************************/<br />&nbsp; select DAID,AID from DocAcceptCheck where YesOrNo=1<br />&nbsp; open find2<br />&nbsp; FETCH NEXT From find2<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; /*是否存在这样的消息记录 收文相关 and 收文号与要添加的收文号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=1 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @MsgContent=Title from DocAcceptBase where <a href="mailto:DAID=@MsgValue">DAID=@MsgValue</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='主题为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的收文需要您承办.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find2<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find2<br />&nbsp; DEALLOCATE find2</p>
<p>declare find3 CURSOR FOR /*游标 用于轮循结果集*/<br />&nbsp; /****************检索发文待批阅表*************************************/<br />&nbsp; select DDID,AID from DocDispatchPostil where YesOrNo=1<br />&nbsp; open find3<br />&nbsp; FETCH NEXT From find3<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; /*是否存在这样的消息记录 发文相关 and 发文号与要添加的收文号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=2 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @MsgContent=Title from DocDispatchBase where <a href="mailto:DDID=@MsgValue">DDID=@MsgValue</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='主题为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的发文需要您批阅.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find3<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find3<br />&nbsp; DEALLOCATE find3</p>
<p>declare find4 CURSOR FOR /*游标 用于轮循结果集*/<br />&nbsp; /****************检索发文待接收表*************************************/<br />&nbsp; select DDID,AID from DocDispatchSend where YesOrNo=1<br />&nbsp; open find4<br />&nbsp; FETCH NEXT From find4<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; /*是否存在这样的消息记录 发文相关 and 发文号与要添加的收文号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=2 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @MsgContent=Title from DocDispatchBase where <a href="mailto:DDID=@MsgValue">DDID=@MsgValue</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='主题为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的发文需要您接收.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find4<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find4<br />&nbsp; DEALLOCATE find4</p>
<p>declare find5 CURSOR FOR /*游标 用于轮循结果集*/<br />&nbsp; /****************检索会议通知待接收表*************************************/<br />&nbsp; select MID,AID from MeetingNotify where Status=0<br />&nbsp; open find5<br />&nbsp; FETCH NEXT From find5<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; /*是否存在这样的消息记录 会议相关 and 会议号与要添加的会议号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=3 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @MsgContent=Title from MeetingBase where <a href="mailto:MID=@MsgValue">MID=@MsgValue</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='主题为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的会议需要您参加.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find5<br />&nbsp; INTO @MsgValue, @MsgAID<br />&nbsp; end<br />&nbsp; CLOSE find5<br />&nbsp; DEALLOCATE find5</p>
<p>declare find6 CURSOR FOR /*游标 用于轮循结果集*/<br />&nbsp; /****************检索部门工作计划表*************************************/<br />&nbsp; select PID,LID,Title from DepartmentProjectBase where Status=1<br />&nbsp; open find6<br />&nbsp; FETCH NEXT From find6<br />&nbsp; INTO @MsgValue, @MsgAID, @MsgContent<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; /*是否存在这样的消息记录 计划相关 and 计划号与要添加的计划号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=4 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=4<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='主题为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的部门工作计划需要您批阅.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find6<br />&nbsp; INTO @MsgValue, @MsgAID, @MsgContent<br />&nbsp; end<br />&nbsp; CLOSE find6<br />&nbsp; DEALLOCATE find6</p>
<p>declare find7 CURSOR FOR /*游标 用于轮循结果集*/<br />&nbsp; /****************检索部门工作计划具体工作安排表*************************************/<br />&nbsp; select PID,OID,Content from DepartmentProjectContent where Agree=1<br />&nbsp; open find7<br />&nbsp; FETCH NEXT From find7<br />&nbsp; INTO @MsgValue, @MsgAID, @MsgContent<br />&nbsp; While @@FETCH_STATUS = 0<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; /*是否存在这样的消息记录 计划相关 and 计划号与要添加的计划号相同 and&nbsp; 消息目标与要添加的目标相同 */<br />&nbsp;&nbsp;&nbsp; if not exists(select *from Sys_Message&nbsp; where MsgType=5 and <a href="mailto:MsgValue=@MsgValue">MsgValue=@MsgValue</a> and <a href="mailto:MsgAID=@MsgAID">MsgAID=@MsgAID</a>) <br />&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @RecCount=count(*) from Sys_Message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgType=5<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @MsgContent='内容为:'+' &quot; <a href="mailto:'+@MsgContent+'">'+@MsgContent+'</a> &quot; '+'的上级工作安排需要您办理.' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert Sys_Message (MsgID,MsgType,MsgValue,MsgContent,MsgAID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values (@RecCount+1,@MsgType,@MsgValue,@MsgContent,@MsgAID)<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; FETCH NEXT FROM find7<br />&nbsp; INTO @MsgValue, @MsgAID, @MsgContent<br />&nbsp; end<br />&nbsp; CLOSE find7<br />&nbsp; DEALLOCATE find7<br />GO<br />////////////////////////////////////////////////////////////////////////////////////////<br />保存 评价 游戏规则 免费注册&nbsp; 资料下载 关于本站&nbsp; <br />问题分类 编程问题 非技术题 富翁列表 我的信息 提出问题 在线富翁 富翁日历 笔记列表 我的笔记 写作笔记 全文检索 《专家门诊》&nbsp; </p>
<p><br />&nbsp; <br />富翁名称 <br />富翁密码 </p>
<p>&nbsp;请记住我 </p>
<p>富翁名称 </p>
<p><br />免费注册 </p>
<p><br />--------------------------------------------------------------------------------</p>
<p><br />--------------------------------------------------------------------------------</p>
<p>大富翁论坛版权所有<br />&nbsp;KeyLife富翁笔记&nbsp; <br />作者: yuanyoufa<br />标题: sql用法!! <br />关键字: <br />分类: 个人专区 <br />密级: 公开 <br />(评分: , 回复: 0, 阅读: 176) ?? <br />1.数据库查询：Select用法<br />Select [Top(数值)] 字段列表 From 数据表 [Where 条件] [Order by 字段] [asc或desc]</p>
<p>2.添加数据：Insert Into用法<br />Insert Into 数据表(字段1,字段2,字段3,&hellip;) Values(字段1的值,字段2的值,字段3的值,&hellip;)</p>
<p>3.删除数据：Delete用法<br />Delete From 数据表 [Where 条件]</p>
<p>4.更新数据：Update用法<br />Update 数据表 Set 字段1=字段值1, 字段2=字段值2, &hellip; [Where 条件]</p>
<p>5.建数据表：Create Table用法<br />Create Table 数据表名(字段1名称,字段1类型,字段2名称 字段2类型, &hellip;)</p>
<p>Access数据表常用数据类型:Text,Char(Number),Memo,Number,Int,Date/Time,Logical,OLEObject</p>
<p>自动编号字段添加例子:create table aaa(id int identity (1, 1) not null,abc varchar(25) null)</p>
<p>6.改数据表：Alter Table用法<br />添加字段：Alter Table 数据表名 Add Column 字段名 字段类型</p>
<p>删除字段：Alter Table 数据表名 Drop Column 字段名</p>
<p>7.删数据表：Drop Table用法</p>
<p>Drop Table 数据表名</p>
<p>&nbsp;</p>
<p>*******************Transact_SQL********************</p>
<p>Alter Table [表] Alter [id] Counter Constraint [表_p] Primary Key 把id列改为自动编号类型,并且设置为主键</p>
<p>--语 句 功 能<br />--数据操作<br />SELECT --从数据库表中检索数据行和列<br />INSERT --向数据库表添加新数据行<br />DELETE --从数据库表中删除数据行<br />UPDATE --更新数据库表中的数据<br />--数据定义<br />CREATE TABLE --创建一个数据库表<br />DROP TABLE --从数据库中删除表<br />ALTER TABLE --修改数据库表结构<br />CREATE VIEW --创建一个视图<br />DROP VIEW --从数据库中删除视图<br />CREATE INDEX --为数据库表创建一个索引<br />DROP INDEX --从数据库中删除索引<br />CREATE PROCEDURE --创建一个存储过程<br />DROP PROCEDURE --从数据库中删除存储过程<br />CREATE TRIGGER --创建一个触发器<br />DROP TRIGGER --从数据库中删除触发器<br />CREATE SCHEMA --向数据库添加一个新模式<br />DROP SCHEMA --从数据库中删除一个模式<br />CREATE DOMAIN --创建一个数据值域<br />ALTER DOMAIN --改变域定义<br />DROP DOMAIN --从数据库中删除一个域<br />--数据控制<br />GRANT --授予用户访问权限<br />DENY --拒绝用户访问<br />REVOKE --解除用户访问权限<br />--事务控制<br />COMMIT --结束当前事务<br />ROLLBACK --中止当前事务<br />SET TRANSACTION --定义当前事务数据访问特征<br />--程序化SQL<br />DECLARE --为查询设定游标<br />EXPLAN --为查询描述数据访问计划<br />OPEN --检索查询结果打开一个游标<br />FETCH --检索一行查询结果<br />CLOSE --关闭游标<br />PREPARE --为动态执行准备SQL 语句<br />EXECUTE --动态地执行SQL 语句<br />DESCRIBE --描述准备好的查询</p>
<p>---局部变量<br />declare @id char(10)<br />--set @id = '10010001'<br />select @id = '10010001'</p>
<p>---全局变量<br />---必须以@@开头</p>
<p>--IF ELSE<br />declare @x int @y int @z int<br />select @x = 1 @y = 2 @z=3<br />if @x &gt; @y<br />print 'x &gt; y' --打印字符串'x &gt; y'<br />else if @y &gt; @z<br />print 'y &gt; z'<br />else print 'z &gt; y'</p>
<p>--CASE<br />use pangu<br />update employee<br />set e_wage =<br />case<br />when job_level = &rsquo;1&rsquo; then e_wage*1.08<br />when job_level = &rsquo;2&rsquo; then e_wage*1.07<br />when job_level = &rsquo;3&rsquo; then e_wage*1.06<br />else e_wage*1.05<br />end</p>
<p>--WHILE CONTINUE BREAK<br />declare @x int @y int @c int<br />select @x = 1 @y=1<br />while @x &lt; 3<br />begin<br />print @x --打印变量x 的值<br />while @y &lt; 3<br />begin<br />select @c = <a href="mailto:100*@x">100*@x</a> + @y<br />print @c --打印变量c 的值<br />select @y = @y + 1<br />end<br />select @x = @x + 1<br />select @y = 1<br />end</p>
<p>--WAITFOR<br />--例 等待1 小时2 分零3 秒后才执行SELECT 语句<br />waitfor delay &rsquo;01:02:03&rsquo;<br />select * from employee<br />--例 等到晚上11 点零8 分后才执行SELECT 语句<br />waitfor time &rsquo;23:08:00&rsquo;<br />select * from employee</p>
<p>&nbsp;</p>
<p>***SELECT***</p>
<p>select *(列名) from table_name(表名) where column_name operator value<br />ex:(宿主)<br />select * from stock_information where stockid = str(nid)<br />stockname = 'str_name' <br />stockname like '% find this %' <br />stockname like '[a-zA-Z]%' --------- ([]指定值的范围)<br />stockname like '[^F-M]%' --------- (^排除指定范围)<br />--------- 只能在使用like关键字的where子句中使用通配符)<br />or stockpath = 'stock_path'<br />or stocknumber &lt; 1000<br />and stockindex = 24<br />not stocksex = 'man'<br />stocknumber between 20 and 100<br />stocknumber in(10,20,30)<br />order by stockid desc(asc) --------- 排序，desc-降序，asc-升序<br />order by 1,2 --------- by列号<br />stockname = (select stockname from stock_information where stockid = 4)<br />--------- 子查询<br />--------- 除非能确保内层select只返回一个行的值，<br />--------- 否则应在外层where子句中用一个in限定符<br />select distinct column_name form table_name --------- distinct指定检索独有的列值，不重复<br />select stocknumber ,&quot;stocknumber + 10&quot; = stocknumber + 10 from table_name<br />select stockname , &quot;stocknumber&quot; = count(*) from table_name group by stockname<br />--------- group by 将表按行分组,指定列中有相同的值<br />having count(*) = 2 --------- having选定指定的组</p>
<p>select * <br />from table1, table2 <br />where table1.id *= table2.id -------- 左外部连接，table1中有的而table2中没有得以null表示<br />table1.id =* table2.id -------- 右外部连接 </p>
<p>select stockname from table1<br />union [all] ----- union合并查询结果集，all-保留重复行<br />select stockname from table2</p>
<p>***insert***</p>
<p>insert into table_name (Stock_name,Stock_number) value (&quot;xxx&quot;,&quot;xxxx&quot;)<br />value (select Stockname , Stocknumber from Stock_table2)---value为select语句</p>
<p>***update***</p>
<p>update table_name set Stockname = &quot;xxx&quot; [where Stockid = 3]<br />Stockname = default<br />Stockname = null<br />Stocknumber = Stockname + 4</p>
<p>***delete***</p>
<p>delete from table_name where Stockid = 3<br />truncate table_name ----------- 删除表中所有行，仍保持表的完整性<br />drop table table_name --------------- 完全删除表</p>
<p>***alter table*** --- 修改数据库表结构</p>
<p>alter table database.owner.table_name add column_name char(2) null .....<br />sp_help table_name ---- 显示表已有特征<br />create table table_name (name char(20), age smallint, lname varchar(30))<br />insert into table_name select ......... ----- 实现删除列的方法（创建新表）<br />alter table table_name drop constraint Stockname_default ---- 删除Stockname的default约束</p>
<p>***function(/*常用函数*/)***</p>
<p>----统计函数----<br />AVG --求平均值<br />COUNT --统计数目<br />MAX --求最大值<br />MIN --求最小值<br />SUM --求和</p>
<p>--AVG<br />use pangu<br />select avg(e_wage) as dept_avgWage<br />from employee<br />group by dept_id</p>
<p>--MAX<br />--求工资最高的员工姓名<br />use pangu<br />select e_name<br />from employee<br />where e_wage =<br />(select max(e_wage)<br />from employee)</p>
<p>--STDEV()<br />--STDEV()函数返回表达式中所有数据的标准差</p>
<p>--STDEVP()<br />--STDEVP()函数返回总体标准差</p>
<p>--VAR()<br />--VAR()函数返回表达式中所有值的统计变异数</p>
<p>--VARP()<br />--VARP()函数返回总体变异数</p>
<p>----算术函数----</p>
<p>/***三角函数***/<br />SIN(float_expression) --返回以弧度表示的角的正弦<br />COS(float_expression) --返回以弧度表示的角的余弦<br />TAN(float_expression) --返回以弧度表示的角的正切<br />COT(float_expression) --返回以弧度表示的角的余切<br />/***反三角函数***/<br />ASIN(float_expression) --返回正弦是FLOAT 值的以弧度表示的角<br />ACOS(float_expression) --返回余弦是FLOAT 值的以弧度表示的角<br />ATAN(float_expression) --返回正切是FLOAT 值的以弧度表示的角<br />ATAN2(float_expression1,float_expression2) <br />--返回正切是float_expression1 /float_expres-sion2的以弧度表示的角<br />DEGREES(numeric_expression)<br />--把弧度转换为角度返回与表达式相同的数据类型可为<br />--INTEGER/MONEY/REAL/FLOAT 类型<br />RADIANS(numeric_expression) --把角度转换为弧度返回与表达式相同的数据类型可为<br />--INTEGER/MONEY/REAL/FLOAT 类型<br />EXP(float_expression) --返回表达式的指数值<br />LOG(float_expression) --返回表达式的自然对数值<br />LOG10(float_expression)--返回表达式的以10 为底的对数值<br />SQRT(float_expression) --返回表达式的平方根<br />/***取近似值函数***/<br />CEILING(numeric_expression) --返回&gt;=表达式的最小整数返回的数据类型与表达式相同可为<br />--INTEGER/MONEY/REAL/FLOAT 类型<br />FLOOR(numeric_expression) --返回&lt;=表达式的最小整数返回的数据类型与表达式相同可为<br />--INTEGER/MONEY/REAL/FLOAT 类型<br />ROUND(numeric_expression) --返回以integer_expression 为精度的四舍五入值返回的数据<br />--类型与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型<br />ABS(numeric_expression) --返回表达式的绝对值返回的数据类型与表达式相同可为<br />--INTEGER/MONEY/REAL/FLOAT 类型<br />SIGN(numeric_expression) --测试参数的正负号返回0 零值1 正数或-1 负数返回的数据类型<br />--与表达式相同可为INTEGER/MONEY/REAL/FLOAT 类型<br />PI() --返回值为&pi; 即3.1415926535897936<br />RAND([integer_expression]) --用任选的[integer_expression]做种子值得出0-1 间的随机浮点数</p>
<p>----字符串函数----<br />ASCII() --函数返回字符表达式最左端字符的ASCII 码值<br />CHAR() --函数用于将ASCII 码转换为字符<br />--如果没有输入0 ~ 255 之间的ASCII 码值CHAR 函数会返回一个NULL 值<br />LOWER() --函数把字符串全部转换为小写<br />UPPER() --函数把字符串全部转换为大写<br />STR() --函数把数值型数据转换为字符型数据<br />LTRIM() --函数把字符串头部的空格去掉<br />RTRIM() --函数把字符串尾部的空格去掉<br />LEFT(),RIGHT(),SUBSTRING() --函数返回部分字符串<br />CHARINDEX(),PATINDEX() --函数返回字符串中某个指定的子串出现的开始位置<br />SOUNDEX() --函数返回一个四位字符码 <br />--SOUNDEX函数可用来查找声音相似的字符串但SOUNDEX函数对数字和汉字均只返回0 值 <br />DIFFERENCE() --函数返回由SOUNDEX 函数返回的两个字符表达式的值的差异<br />--0 两个SOUNDEX 函数返回值的第一个字符不同<br />--1 两个SOUNDEX 函数返回值的第一个字符相同<br />--2 两个SOUNDEX 函数返回值的第一二个字符相同<br />--3 两个SOUNDEX 函数返回值的第一二三个字符相同<br />--4 两个SOUNDEX 函数返回值完全相同</p>
<p><br />QUOTENAME() --函数返回被特定字符括起来的字符串<br />/*select quotename('abc', '{') quotename('abc')<br />运行结果如下<br />----------------------------------{<br />{abc} [abc]*/</p>
<p>REPLICATE() --函数返回一个重复character_expression 指定次数的字符串<br />/*select replicate('abc', 3) replicate( 'abc', -2)<br />运行结果如下<br />----------- -----------<br />abcabcabc NULL*/</p>
<p>REVERSE() --函数将指定的字符串的字符排列顺序颠倒<br />REPLACE() --函数返回被替换了指定子串的字符串<br />/*select replace('abc123g', '123', 'def')<br />运行结果如下<br />----------- -----------<br />abcdefg*/</p>
<p>SPACE() --函数返回一个有指定长度的空白字符串<br />STUFF() --函数用另一子串替换字符串指定位置长度的子串</p>
<p>----数据类型转换函数----<br />CAST() 函数语法如下<br />CAST() (&lt;expression&gt; AS &lt;data_ type&gt;[ length ])<br />CONVERT() 函数语法如下<br />CONVERT() (&lt;data_ type&gt;[ length ], &lt;expression&gt; [, style])</p>
<p>select cast(100+99 as char) convert(varchar(12), getdate())<br />运行结果如下<br />------------------------------ ------------<br />199 Jan 15 2000</p>
<p>----日期函数----<br />DAY() --函数返回date_expression 中的日期值<br />MONTH() --函数返回date_expression 中的月份值<br />YEAR() --函数返回date_expression 中的年份值<br />DATEADD(&lt;datepart&gt; ,&lt;number&gt; ,&lt;date&gt;) <br />--函数返回指定日期date 加上指定的额外日期间隔number 产生的新日期<br />DATEDIFF(&lt;datepart&gt; ,&lt;number&gt; ,&lt;date&gt;)<br />--函数返回两个指定日期在datepart 方面的不同之处<br />DATENAME(&lt;datepart&gt; , &lt;date&gt;) --函数以字符串的形式返回日期的指定部分<br />DATEPART(&lt;datepart&gt; , &lt;date&gt;) --函数以整数值的形式返回日期的指定部分<br />GETDATE() --函数以DATETIME 的缺省格式返回系统当前的日期和时间</p>
<p>----系统函数----<br />APP_NAME() --函数返回当前执行的应用程序的名称<br />COALESCE() --函数返回众多表达式中第一个非NULL 表达式的值<br />COL_LENGTH(&lt;'table_name'&gt;, &lt;'column_name'&gt;) --函数返回表中指定字段的长度值<br />COL_NAME(&lt;table_id&gt;, &lt;column_id&gt;) --函数返回表中指定字段的名称即列名<br />DATALENGTH() --函数返回数据表达式的数据的实际长度<br />DB_ID(['database_name']) --函数返回数据库的编号<br />DB_NAME(database_id) --函数返回数据库的名称<br />HOST_ID() --函数返回服务器端计算机的名称<br />HOST_NAME() --函数返回服务器端计算机的名称<br />IDENTITY(&lt;data_type&gt;[, seed increment]) [AS column_name])<br />--IDENTITY() 函数只在SELECT INTO 语句中使用用于插入一个identity column列到新表中<br />/*select identity(int, 1, 1) as column_name<br />into newtable<br />from oldtable*/<br />ISDATE() --函数判断所给定的表达式是否为合理日期<br />ISNULL(&lt;check_expression&gt;, &lt;replacement_value&gt;) --函数将表达式中的NULL 值用指定值替换<br />ISNUMERIC() --函数判断所给定的表达式是否为合理的数值<br />NEWID() --函数返回一个UNIQUEIDENTIFIER 类型的数值<br />NULLIF(&lt;expression1&gt;, &lt;expression2&gt;)<br />--NULLIF 函数在expression1 与expression2 相等时返回NULL 值若不相等时则返回expression1 的值<br />单查询 </p>
<p>　　简单的Transact-SQL查询只包括选择列表、FROM子句和WHERE子句。它们分别说明所查询列、查询的表或视图、以及搜索条件等。<br />　　例如，下面的语句查询testtable表中姓名为&ldquo;张三&rdquo;的nickname字段和email字段。</p>
<p><br />&nbsp;</p>
<p><br />&nbsp;　　SELECT nickname,email<br />　　FROM testtable<br />　　WHERE name='张三' </p>
<p><br />　　(一) 选择列表</p>
<p>　　选择列表(select_list)指出所查询列，它可以是一组列名列表、星号、表达式、变量(包括局部变量和全局变量)等构成。</p>
<p>　　1、选择所有列</p>
<p>　　例如，下面语句显示testtable表中所有列的数据：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT *<br />　　FROM testtable </p>
<p>&nbsp;</p>
<p>　　2、选择部分列并指定它们的显示次序</p>
<p>　　查询结果集合中数据的排列顺序与选择列表中所指定的列名排列顺序相同。<br />　　例如：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT nickname,email<br />　　FROM testtable </p>
<p>&nbsp;</p>
<p>　　3、更改列标题</p>
<p>　　在选择列表中，可重新指定列标题。定义格式为：<br />　　列标题=列名<br />　　列名 列标题<br />　　如果指定的列标题不是标准的标识符格式时，应使用引号定界符，例如，下列语句使用汉字显示列标题：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT 昵称=nickname,电子邮件=email<br />　　FROM testtable </p>
<p>&nbsp;</p>
<p><br />　　4、删除重复行</p>
<p>　　SELECT语句中使用ALL或DISTINCT选项来显示表中符合条件的所有行或删除其中重复的数据行，默认为ALL。使用DISTINCT选项时，对于所有重复的数据行在SELECT返回的结果集合中只保留一行。</p>
<p>　　5、限制返回的行数</p>
<p>　　使用TOP n [PERCENT]选项限制返回的数据行数，TOP n说明返回n行，而TOP n PERCENT时，说明n是表示一百分数，指定返回的行数等于总行数的百分之几。<br />　　例如：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT TOP 2 *<br />　　FROM testtable<br />　　SELECT TOP 20 PERCENT *<br />　　FROM testtable </p>
<p>&nbsp;</p>
<p><br />　　(二)FROM子句 </p>
<p>　　FROM子句指定SELECT语句查询及与查询相关的表或视图。在FROM子句中最多可指定256个表或视图，它们之间用逗号分隔。<br />　　在FROM子句同时指定多个表或视图时，如果选择列表中存在同名列，这时应使用对象名限定这些列所属的表或视图。例如在usertable和citytable表中同时存在cityid列，在查询两个表中的cityid时应使用下面语句格式加以限定：</p>
<p>&nbsp;</p>
<p><br />&nbsp;　　SELECT username,citytable.cityid<br />　　FROM usertable,citytable<br />　　WHERE usertable.cityid=citytable.cityid </p>
<p>&nbsp;</p>
<p>　　在FROM子句中可用以下两种格式为表或视图指定别名：<br />　　表名 as 别名<br />　　表名 别名</p>
<p>) FROM子句</p>
<p>　　FROM子句指定SELECT语句查询及与查询相关的表或视图。在FROM子句中最多可指定256个表或视图，它们之间用逗号分隔。<br />　　在FROM子句同时指定多个表或视图时，如果选择列表中存在同名列，这时应使用对象名限定这些列所属的表或视图。例如在usertable和citytable表中同时存在cityid列，在查询两个表中的cityid时应使用下面语句格式加以限定：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT username,citytable.cityid<br />　　FROM usertable,citytable<br />　　WHERE usertable.cityid=citytable.cityid </p>
<p>&nbsp;</p>
<p>　　在FROM子句中可用以下两种格式为表或视图指定别名：<br />　　表名 as 别名<br />　　表名 别名<br />　　例如上面语句可用表的别名格式表示为：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT username,b.cityid<br />　　FROM usertable a,citytable b<br />　　WHERE a.cityid=b.cityid </p>
<p>&nbsp;</p>
<p>　　SELECT不仅能从表或视图中检索数据，它还能够从其它查询语句所返回的结果集合中查询数据。</p>
<p>　　例如：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT a.au_fname+a.au_lname<br />　　FROM authors a,titleauthor ta<br />　　(SELECT title_id,title<br />　　FROM titles<br />　　WHERE ytd_sales&gt;10000<br />　　) AS t<br />　　WHERE a.au_id=ta.au_id<br />　　AND ta.title_id=t.title_id </p>
<p>&nbsp;</p>
<p>　　此例中，将SELECT返回的结果集合给予一别名t，然后再从中检索数据。</p>
<p>　　(三) 使用WHERE子句设置查询条件</p>
<p>　　WHERE子句设置查询条件，过滤掉不需要的数据行。例如下面语句查询年龄大于20的数据：</p>
<p>&nbsp;</p>
<p>&nbsp;　　SELECT *<br />　　FROM usertable<br />　　WHERE age&gt;20 </p>
<p>&nbsp;</p>
<p>　　WHERE子句可包括各种条件运算符：<br />　　比较运算符(大小比较)：&gt;、&gt;=、=、&lt;、&lt;=、&lt;&gt;、!&gt;、!&lt;<br />　　范围运算符(表达式值是否在指定的范围)：BETWEEN&hellip;AND&hellip;<br />　　NOT BETWEEN&hellip;AND&hellip;<br />　　列表运算符(判断表达式是否为列表中的指定项)：IN (项1,项2&hellip;&hellip;)<br />　　NOT IN (项1,项2&hellip;&hellip;)<br />　　模式匹配符(判断值是否与指定的字符通配格式相符):LIKE、NOT LIKE<br />　　空值判断符(判断表达式是否为空)：IS NULL、NOT IS NULL<br />　　逻辑运算符(用于多条件的逻辑连接)：NOT、AND、OR</p>
<p>　　1、范围运算符例：age BETWEEN 10 AND 30相当于age&gt;=10 AND age&lt;=30<br />　　2、列表运算符例：country IN ('Germany','China')<br />　　3、模式匹配符例：常用于模糊查找，它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br />　　可使用以下通配字符：<br />　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br />　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br />　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。<br />　　例如：<br />　　限制以Publishing结尾，使用LIKE '%Publishing'<br />　　限制以A开头：LIKE '[A]%'<br />　　限制以A开头外：LIKE '[^A]%'</p>
<p>4、空值判断符 <br />例WHERE age IS NULL</p>
<p>　　5、逻辑运算符：优先级为NOT、AND、OR</p>
<p>　　(四)查询结果排序 </p>
<p>　　使用ORDER BY子句对查询返回的结果按一列或多列排序。ORDER BY子句的语法格式为：<br />　　ORDER BY {column_name [ASC|DESC]} [,&hellip;n]<br />　　其中ASC表示升序，为默认值，DESC为降序。ORDER BY不能按ntext、text和image数据类型进行排<br />　　序。<br />　　例如：</p>
<p>&nbsp;　　SELECT *<br />　　FROM usertable<br />　　ORDER BY age desc,userid ASC </p>
<p>　　另外，可以根据表达式进行排序。</p>
<p>　　二、 联合查询</p>
<p>　　UNION运算符可以将两个或两个以上上SELECT语句的查询结果集合合并成一个结果集合显示，即执行联合查询。UNION的语法格式为：</p>
<p>&nbsp;　　select_statement<br />　　UNION [ALL] selectstatement<br />　　[UNION [ALL] selectstatement][&hellip;n] </p>
<p>　　其中selectstatement为待联合的SELECT查询语句。</p>
<p>　　ALL选项表示将所有行合并到结果集合中。不指定该项时，被联合查询结果集合中的重复行将只保留一行。</p>
<p>　　联合查询时，查询结果的列标题为第一个查询语句的列标题。因此，要定义列标题必须在第一个查询语句中定义。要对联合查询结果排序时，也必须使用第一查询语句中的列名、列标题或者列序号。 </p>
<p><br />　　在使用UNION 运算符时，应保证每个联合查询语句的选择列表中有相同数量的表达式，并且每个查询选择表达式应具有相同的数据类型，或是可以自动将它们转换为相同的数据类型。在自动转换时，对于数值类型，系统将低精度的数据类型转换为高精度的数据类型。</p>
<p>　　在包括多个查询的UNION语句中，其执行顺序是自左至右，使用括号可以改变这一执行顺序。例如：</p>
<p>　　查询1 UNION (查询2 UNION 查询3)</p>
<p>　　三、连接查询</p>
<p>　　通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。</p>
<p>　　在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，尔后通过连接进行查询。</p>
<p>　　连接可以在SELECT 语句的FROM子句或WHERE子句中建立，似是而非在FROM子句中指出连接时有助于将连接操作与WHERE子句中的搜索条件区分开来。所以，在Transact-SQL中推荐使用这种方法。</p>
<p>　　SQL-92标准所定义的FROM子句的连接语法格式为：</p>
<p>&nbsp;　　FROM join_table join_type join_table<br />　　[ON (join_condition)] </p>
<p>　　其中join_table指出参与连接操作的表名，连接可以对同一个表操作，也可以对多表操作，对同一个表操作的连接又称做自连接。</p>
<p>&nbsp;</p>
<p>&nbsp;<br />join_type 指出连接类型，可分为三种：内连接、外连接和交叉连接。内连接(INNER JOIN)使用比较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行。 </p>
<p><br />　　交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>
<p>　　连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑运算符等构成。</p>
<p>　　无论哪种连接都不能对text、ntext和image数据类型列进行直接连接，但可以对这三种列进行间接连接。例如：</p>
<p>&nbsp;　　SELECT p1.pub_id,p2.pub_id,p1.pr_info<br />　　FROM pub_info AS p1 INNER JOIN pub_info AS p2<br />　　ON DATALENGTH(p1.pr_info)=DATALENGTH(p2.pr_info) </p>
<p>　　(一)内连接<br />　　内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。内连接分三种：<br />　　1、等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。<br />　　2、不等连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;。<br />　　3、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。<br />　　例，下面使用等值连接列出authors和publishers表中位于同一城市的作者和出版社：</p>
<p>&nbsp;　　SELECT *<br />　　FROM authors AS a INNER JOIN publishers AS p<br />　　ON a.city=p.city<br />　　又如使用自然连接，在选择列表中删除authors 和publishers 表中重复列(city和state)：<br />　　SELECT a.*,p.pub_id,p.pub_name,p.country<br />　　FROM authors AS a INNER JOIN publishers AS p<br />　　ON a.city=p.city </p>
<p>　　(二)外连接<br />　　内连接时，返回查询结果集合中的仅是符合查询条件( WHERE 搜索条件或 HAVING 条件)和连接条件的行。而采用外连接时，它返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左外连接时)、右表(右外连接时)或两个边接表(全外连接)中的所有数据行。如下面使用左外连接将论坛内容和作者信息连接起来：</p>
<p>&nbsp;　　SELECT a.*,b.* FROM luntan LEFT JOIN usertable as b<br />　　ON a.username=b.username </p>
<p>　　下面使用全外连接将city表中的所有作者以及user表中的所有作者，以及他们所在的城市：</p>
<p>&nbsp;　　SELECT a.*,b.*<br />　　FROM city as a FULL OUTER JOIN user as b<br />　　ON a.username=b.username </p>
<p><br />　　(三)交叉连接<br />　　交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。例，titles表中有6类图书，而publishers表中有8家出版社，则下列交叉连接检索到的记录数将等</p>
<p>&nbsp;　　于6*8=48行。<br />　　SELECT type,pub_name<br />　　FROM titles CROSS JOIN publishers<br />　　ORDER BY type<br />　　[Post=0][/Post] </p>
<p>--------------------------------------------------------------------------------<br />--------------------------------------------------------------------------------</p>
<p>大富翁论坛版权所有<br />&nbsp;KeyLife富翁笔记&nbsp; <br />作者: snowspace1981<br />标题: sql优化 <br />关键字: sql优化 <br />分类: Sql <br />密级: 公开 <br />(评分: , 回复: 0, 阅读: 248) ?? <br />1.合理使用索引<br />索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用IBM最先提出的ISAM索引结构。索引的使用要恰到好处，其使用原则如下： <br />●在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。 <br />●在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引。 <br />●在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的&ldquo;性别&rdquo;列上只有&ldquo;男&rdquo;与&ldquo;女&rdquo;两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 <br />●如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。 <br />●使用系统工具。如Informix数据库有一个tbcheck工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用tbcheck工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。 </p>
<p>(1)在下面两条select语句中:<br />&nbsp;&nbsp; select * from table1&nbsp; where&nbsp; field1&lt;=10000 and field1&gt;=0;<br />&nbsp;&nbsp; select * from table1&nbsp; where&nbsp; field1&gt;=0 and field1&lt;=10000;<br />&nbsp;&nbsp; 如果数据表中的数据field1都&gt;=0,则第一条select语句要比第二条select语句效率高的多，因为第二条select语句的第一个条件耗费了大量的系统资源。<br />&nbsp;&nbsp; 第一个原则：在where子句中应把最具限制性的条件放在最前面。</p>
<p>(2)在下面的select语句中:<br />&nbsp;&nbsp; select * from tab&nbsp; where&nbsp; a=&hellip; and b=&hellip; and c=&hellip;;<br />&nbsp; 若有索引index(a,b,c)，则where子句中字段的顺序应和索引中字段顺序一致。<br />&nbsp;&nbsp; 第二个原则：where子句中字段的顺序应和索引中字段顺序一致。</p>
<p>以下假设在field1上有唯一索引I1，在field2上有非唯一索引I2。<br />(3) select field3,field4 from tb where field1='sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 快<br />&nbsp;&nbsp;&nbsp; select * from tb where field1='sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 慢，<br />因为后者在索引扫描后要多一步ROWID表访问。</p>
<p>(4) select field3,field4 from tb where field1&gt;='sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 快<br />select field3,field4 from tb where field1&gt;'sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 慢<br />因为前者可以迅速定位索引。</p>
<p>(5) select field3,field4 from tb where field2 like 'R%'&nbsp;&nbsp;&nbsp; 快<br />&nbsp;&nbsp;&nbsp; select field3,field4 from tb where field2 like '%R'&nbsp;&nbsp;&nbsp; 慢，<br />&nbsp;&nbsp;&nbsp; 因为后者不使用索引。</p>
<p>(6) 使用函数如：<br />select field3,field4 from tb where upper(field2)='RMN'不使用索引。<br />如果一个表有两万条记录，建议不使用函数；如果一个表有五万条以上记录，严格禁止使用函数！两万条记录以下没有限制。</p>
<p>(7) 空值不在索引中存储，所以<br />&nbsp;&nbsp;&nbsp; select field3,field4 from tb where field2 is[not] null不使用索引。</p>
<p>(8) 不等式如<br />&nbsp;&nbsp;&nbsp; select field3,field4 from tb where field2!='TOM'不使用索引。<br />&nbsp;&nbsp;&nbsp; 相似地，<br />&nbsp;&nbsp;&nbsp; select field3,field4 from tb where field2 not in('M','P')不使用索引。</p>
<p>(9) 多列索引，只有当查询中索引首列被用于条件时，索引才能被使用。</p>
<p>(10)&nbsp; MAX，MIN等函数，如<br />Select max(field2) from tb使用索引。所以，如果需要对字段取max，min，sum等，应该加索引。<br />一次只使用一个聚集函数，如：<br />select &ldquo;min&rdquo;=min(field1), &ldquo;max&rdquo;=max(field1)&nbsp; from tb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />不如：select &ldquo;min&rdquo;=(select min(field1) from tb) , &ldquo;max&rdquo;=(select max(field1) from tb)&nbsp;&nbsp;&nbsp; </p>
<p>(11) 重复值过多的索引不会被查询优化器使用。而且因为建了索引，修改该字段值时还要修改索引，所以更新该字段的操作比没有索引更慢。</p>
<p>(12) 索引值过大（如在一个char(40)的字段上建索引），会造成大量的I/O开销（甚至会超过表扫描的I/O开销）。因此，尽量使用整数索引。 Sp_estspace可以计算表和索引的开销。</p>
<p>(13) 对于多列索引，order by的顺序必须和索引的字段顺序一致。</p>
<p>(14) 在sybase中，如果order by的字段组成一个簇索引，那么无须做order by。记录的排列顺序是与簇索引一致的。</p>
<p>(15) 多表联结（具体查询方案需要通过测试得到）<br />&nbsp;&nbsp;&nbsp; where子句中限定条件尽量使用相关联的字段，且尽量把相关联的字段放在前面。<br />&nbsp;&nbsp;&nbsp; select a.field1,b.field2 from a,b where a.field3=b.field3<br />&nbsp;1. field3上没有索引的情况下:<br />&nbsp;&nbsp;&nbsp; 对a作全表扫描，结果排序<br />&nbsp;&nbsp;&nbsp; 对b作全表扫描，结果排序<br />&nbsp;&nbsp;&nbsp; 结果合并。<br />&nbsp;&nbsp;&nbsp; 对于很小的表或巨大的表比较合适。</p>
<p>&nbsp;2. field3上有索引<br />&nbsp;&nbsp;&nbsp; 按照表联结的次序，b为驱动表，a为被驱动表<br />&nbsp;&nbsp;&nbsp; 对b作全表扫描<br />&nbsp;&nbsp;&nbsp; 对a作索引范围扫描<br />&nbsp;&nbsp;&nbsp; 如果匹配，通过a的rowid访问</p>
<p>(16) 避免一对多的join。如：<br />&nbsp;&nbsp;&nbsp;&nbsp; select tb1.field3,tb1.field4,tb2.field2 from tb1,tb2 where tb1.field2=tb2.field2 and tb1.field2=&lsquo;BU1032&rsquo; and tb2.field2= &lsquo;aaa&rsquo;<br />&nbsp;&nbsp;&nbsp;&nbsp; 不如：<br />&nbsp;&nbsp;&nbsp;&nbsp; declare @a varchar(80)<br />select @a=field2 from tb2 where field2=&lsquo;aaa&rsquo;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; select tb1.field3,tb1.field4,@a from tb1 where field2= &lsquo;aaa&rsquo;</p>
<p>(16) 子查询<br />&nbsp;&nbsp;&nbsp; 用exists/not exists代替in/not in操作<br />&nbsp;&nbsp;&nbsp; 比较：<br />&nbsp;&nbsp;&nbsp; select a.field1 from a where a.field2 in(select b.field1 from b where b.field2=100)<br />&nbsp;&nbsp;&nbsp; select a.field1 from a where exists( select 1 from b where a.field2=b.field1 and b.field2=100)</p>
<p>&nbsp;&nbsp;&nbsp; select field1 from a where field1 not in( select field2 from b)<br />&nbsp;&nbsp;&nbsp; select field1 from a where not exists( select 1 from b where b.field2=a.field1)</p>
<p>(17) 主、外键主要用于数据约束，sybase中创建主键时会自动创建索引，外键与索引无关，提高性能必须再建索引。</p>
<p>(18) char类型的字段不建索引比int类型的字段不建索引更糟糕。建索引后性能只稍差一点。</p>
<p>(19)&nbsp;&nbsp; 使用count(*)而不要使用count(column_name)，避免使用count(distinct column_name)。</p>
<p>(20) 等号右边尽量不要使用字段名，如：<br />select * from tb where field1 = field3<br />&nbsp;<br />(21) 避免使用or条件，因为or不使用索引。</p>
<p>2.避免使用order by和group by字句。<br />&nbsp;&nbsp;&nbsp; 因为使用这两个子句会占用大量的临时空间(tempspace),如果一定要使用，可用视图、人工生成临时表的方法来代替。<br />&nbsp;&nbsp; 如果必须使用，先检查memory、tempdb的大小。<br />&nbsp;&nbsp; 测试证明，特别要避免一个查询里既使用join又使用group by，速度会非常慢！</p>
<p>3.尽量少用子查询，特别是相关子查询。因为这样会导致效率下降。<br />一个列的标签同时在主查询和where子句中的查询中出现，那么很可能当主查询中的列值改变之后，子查询必须重新查询一次。查询嵌套层次越多，效率越低，因此应当尽量避免子查询。如果子查询不可避免，那么要在子查询中过滤掉尽可能多的行。 </p>
<p>&nbsp;<br />&nbsp;<br />4．消除对大型表行数据的顺序存取 <br />在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套3层的查询，如果每层都查询1000行，那么这个查询就要查询10亿行数据。避免这种情况的主要方法就是对连接的列进行索引。例如，两个表：学生表（学号、姓名、年龄&hellip;&hellip;）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在&ldquo;学号&rdquo;这个连接字段上建立索引。 <br />还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的where子句强迫优化器使用顺序存取。下面的查询将强迫对orders表执行顺序操作： <br />SELECT ＊ FROM orders WHERE (customer_num=104 AND order_num&gt;1001) OR order_num=1008 <br />虽然在customer_num和order_num上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句： <br />SELECT ＊ FROM orders WHERE customer_num=104 AND order_num&gt;1001 <br />UNION <br />SELECT ＊ FROM orders WHERE order_num=1008 <br />这样就能利用索引路径处理查询。 <br />5．避免困难的正规表达式 <br />MATCHES和LIKE关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时间。例如：SELECT ＊ FROM customer WHERE zipcode LIKE &ldquo;98_ _ _&rdquo; <br />即使在zipcode字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如果把语句改为SELECT ＊ FROM customer WHERE zipcode &gt;&ldquo;98000&rdquo;，在执行查询时就会利用索引来查询，显然会大大提高速度。 <br />另外，还要避免非开始的子串。例如语句：SELECT ＊ FROM customer WHERE zipcode[2，3] &gt;&ldquo;80&rdquo;，在where子句中采用了非开始子串，因而这个语句也不会使用索引。 <br />6．使用临时表加速查询 <br />把表的一个子集进行排序并创建临时表，有时能加速查询。它有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： <br />SELECT cust.name，rcvbles.balance，&hellip;&hellip;other columns <br />FROM cust，rcvbles <br />WHERE cust.customer_id = rcvlbes.customer_id <br />AND rcvblls.balance&gt;0 <br />AND cust.postcode&gt;&ldquo;98000&rdquo; <br />ORDER BY cust.name <br />如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个临时文件中，并按客户的名字进行排序： <br />SELECT cust.name，rcvbles.balance，&hellip;&hellip;other columns <br />FROM cust，rcvbles <br />WHERE cust.customer_id = rcvlbes.customer_id <br />AND rcvblls.balance&gt;0 <br />ORDER BY cust.name <br />INTO TEMP cust_with_balance <br />然后以下面的方式在临时表中查询： <br />SELECT ＊ FROM cust_with_balance <br />WHERE postcode&gt;&ldquo;98000&rdquo; <br />临时表中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘I/O，所以查询工作量可以得到大幅减少。 <br />注意：临时表创建后不会反映主表的修改。在主表中数据频繁修改的情况下，注意不要丢失数据。 <br />7．用排序来取代非顺序存取 <br />非顺序磁盘存取是最慢的操作，表现在磁盘存取臂的来回移动。SQL语句隐藏了这一情况，使得我们在写应用程序时很容易写出要求存取大量非顺序页的查询。 <br />有些时候，用数据库的排序能力来替代非顺序的存取能改进查询。&nbsp; </p>
<p>&nbsp;</p>
<p>2005-9-5 9:10:10&nbsp;&nbsp;&nbsp; <br />&nbsp;查看评语???&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;2005-9-5 10:25:17&nbsp;&nbsp;&nbsp; 关于本文的一些问题以下假设在field1上有唯一索引I1，在field2上有非唯一索引I2。<br />(3) select field3,field4 from tb where field1='sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 快<br />&nbsp;&nbsp;&nbsp; select * from tb where field1='sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 慢<br />&nbsp;因为后者在索引扫描后要多一步ROWID表访问。</p>
<p>&nbsp;问题：<br />&nbsp;为什么后者在索引扫描后多一步ROWID表的访问？<br />&nbsp;在我的概念中：<br />&nbsp;索引表记录的是 字段值和ROWID,在按某个所有字段查询的时候。 <br />&nbsp;先在所有表里找到符合条件的ROWID，<br />&nbsp;然后再根据ROWID读取表中的数据（就是select 后面跟的n个字段）<br />&nbsp;这样的话，其实两个查询都要对ROWID进行访问的呀。<br />&nbsp;<br />&nbsp;我的想法有什么不对的？请指教？</p>
<p>&nbsp;select field2,field3,field4 from tb where field1='sdf' <br />&nbsp;这个查询要不要对索引扫描后再多一步的ROWID表访问的？</p>
<p>(4) select field3,field4 from tb where field1&gt;='sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 快<br />select field3,field4 from tb where field1&gt;'sdf'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 慢<br />因为前者可以迅速定位索引。</p>
<p>问题：<br />为什么前者可以迅速定位？呵呵，原来上面是怎么解释的？</p>
<p>(12) 索引值过大（如在一个char(40)的字段上建索引），会造成大量的I/O开销（甚至会超过表扫描的I/O开销）。因此，尽量使用整数索引。 Sp_estspace可以计算表和索引的开销。<br />问题：<br />找不到 Sp_estspace 对象，我是在ms sql server 2000上找的。</p>
<p><br />(16) 避免一对多的join。如：<br />&nbsp;&nbsp;&nbsp;&nbsp; select tb1.field3,tb1.field4,tb2.field2 from tb1,tb2 where tb1.field2=tb2.field2 and tb1.field2=&lsquo;BU1032&rsquo; and tb2.field2= &lsquo;aaa&rsquo;<br />&nbsp;&nbsp;&nbsp;&nbsp; 不如：<br />&nbsp;&nbsp;&nbsp;&nbsp; declare @a varchar(80)<br />select @a=field2 from tb2 where field2=&lsquo;aaa&rsquo;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; select tb1.field3,tb1.field4,@a from tb1 where field2= &lsquo;aaa&rsquo;</p>
<p>问题：<br />&nbsp;&nbsp;&nbsp;&nbsp; select tb1.field3,tb1.field4,tb2.field2 from tb1,tb2 where tb1.field2=tb2.field2 and tb1.field2=&lsquo;BU1032&rsquo; and tb2.field2= &lsquo;aaa&rsquo;<br />这个结果查处理应该是个空的结果集啊。<br />我觉得 和下面的这段查询返回的结果集不一定等价<br />select @a=field2 from tb2 where field2=&lsquo;aaa&rsquo;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; select tb1.field3,tb1.field4,@a from tb1 where field2= &lsquo;aaa&rsquo;</p>
<p>(20) 等号右边尽量不要使用字段名，如：<br />select * from tb where field1 = field3</p>
<p>问题：<br />等号右边尽量不要使用字段名？ 那 field1，field3&nbsp; 是什么？</p>
<p><br />(21) 避免使用or条件，因为or不使用索引。</p>
<p>2.避免使用order by和group by字句。<br />&nbsp;&nbsp;&nbsp; 因为使用这两个子句会占用大量的临时空间(tempspace),如果一定要使用，可用视图、人工生成临时表的方法来代替。<br />&nbsp;&nbsp; 如果必须使用，先检查memory、tempdb的大小。<br />&nbsp;&nbsp; 测试证明，特别要避免一个查询里既使用join又使用group by，速度会非常慢！<br />问题： <br />可用视图、人工生成临时表的方法来代替。&nbsp; 怎么做啊？<br />特别要避免一个查询里既使用join又使用group by，速度会非常慢！ 假如真的需要做连接还要做分组统计（group），用什么比较好？<br />还有问一下 select * from tb1,tb2 where tb1.ID=tb2.ID&nbsp; 和 select * from tb1 inner join tb2 on tb1.ID=tb2.ID<br />哪个执行效率高？ </p>
<p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>--------------------------------------------------------------------------------</p>
<p><br />--------------------------------------------------------------------------------</p>
<p>大富翁论坛版权所有<br />&nbsp;KeyLife富翁笔记&nbsp; <br />作者: fanghongbin<br />标题: sql转 <br />关键字: sql <br />分类: 个人专区 <br />密级: 公开 <br />(评分:★★★★★ , 回复: 1, 阅读: 1173) ?? <br />daxia003 (2001-12-17 17:16) 794281 <br />收集SQL语句使用技巧！！！（只要不是太普通的就行了！带条例子语句！）</p>
<p>一条十分！！！</p>
<p>先到先得！！！ <br />GZCYP (2001-12-17 17:21) <br />SQL没有技巧，只有经验和学习。 <br />SuperJS (2001-12-17 17:30) <br />给你一条以前在csdn看到的！<br />&nbsp; SELECT DISTINCT SUBSTRING( KMM102.KMM102_BGT_TYPE,1,4 ) AS BGT_TYPE,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( CASE SUBSTRING( KMM102.KMM102_BGT_TYPE,3,2 ) WHEN &quot;09&quot; THEN &quot;1&quot; WHEN &quot;10&quot; THEN &quot;2&quot; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN &quot;11&quot; THEN &quot;3&quot; ELSE &quot;9&quot; END ) AS BGT_CLASS,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBSTRING( KMM102.KMM102_BGT_TYPE,1,2 ) AS BGT_TEAM,&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( ISNULL( (SELECT SUBSTRING(KMC101.KMC101_NAME,CHARINDEX(&quot;-&quot;,KMC101.KMC101_NAME)+1,12) FROM KMC101&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE ( KMC101.KMC101_TYPE = &quot;BUDGETCODE&quot; ) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND ( KMC101.KMC101_CODE = SUBSTRING( KMM102.KMM102_BGT_TYPE,1,4 ) + &quot;00&quot; ) ),&quot;&quot; ) ) AS BGT_NAME,&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_JAN,0 ) ) AS BGT_AMT01,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_FEB,0 ) ) AS BGT_AMT02,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_MAR,0 ) ) AS BGT_AMT03,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_APR,0 ) ) AS BGT_AMT04,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_MAY,0 ) ) AS BGT_AMT05,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_JUN,0 ) ) AS BGT_AMT06,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_JUL,0 ) ) AS BGT_AMT07,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_AUG,0 ) ) AS BGT_AMT08,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_SEP,0 ) ) AS BGT_AMT09,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_OCT,0 ) ) AS BGT_AMT10,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_NOV,0 ) ) AS BGT_AMT11,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_DEC,0 ) ) AS BGT_AMT12,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( SUM( ISNULL( KMM101.KMM101_BGT_JAN,0 ) ) + SUM( ISNULL( KMM101.KMM101_BGT_FEB,0 ) ) + <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_MAR,0 ) ) + SUM( ISNULL( KMM101.KMM101_BGT_APR,0 ) ) + <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_MAY,0 ) ) + SUM( ISNULL( KMM101.KMM101_BGT_JUN,0 ) ) + <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_JUL,0 ) ) + SUM( ISNULL( KMM101.KMM101_BGT_AUG,0 ) ) + <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_SEP,0 ) ) + SUM( ISNULL( KMM101.KMM101_BGT_OCT,0 ) ) + <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( KMM101.KMM101_BGT_NOV,0 ) ) + SUM( ISNULL( KMM101.KMM101_BGT_DEC,0 ) ) ) AS AMT01,&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( &quot;XXXXXXXX&quot; ) AS AMT02,&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( ( CASE WHEN ( CONVERT(CHAR(8),KMM102.KMM102_CHK_DATE,112) &lt; &quot;YYYYMMDD&quot; ) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEN KMM102.KMM102_CHK_AMT ELSE 0 END ),0 ) ) AS AMT09,&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( ( CASE WHEN ( ( CONVERT(CHAR(8),KMM102.KMM102_OVER_DATE,112) &lt; &quot;YYYYMMDD&quot; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND KMM102.KMM102_OVER_STATUS &lt;&gt; &quot;00&quot; ) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEN KMM102.KMM102_OVER_AMT <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN ( ( CONVERT(CHAR(8),KMM102.KMM102_OVER_DATE,112) &lt; &quot;YYYYMMDD&quot; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND KMM102.KMM102_OVER_STATUS = &quot;00&quot; ) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEN KMM102.KMM102_OVER_AMT ELSE 0 END ),0 ) ) AS AMT07,&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( ( SELECT CASE WHEN ( ( CONVERT(CHAR(8),KMM103.KMM103_PAY_DATE,112) &lt; &quot;YYYYMMDD&quot; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND KMM103.KMM103_PAY_STATUS &lt;&gt; &quot;2&quot; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEN KMM103.KMM103_PAY_AMT ELSE 0 END <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM KMM103<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE ( KMM103.KMM103_YY = KMM102.KMM102_YY )&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND ( KMM103.KMM103_BGT_KIND = KMM102.KMM102_BGT_KIND )&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND ( KMM103.KMM103_CASE_NO = KMM102.KMM102_CASE_NO ) ),0 ) ) AS AMT03,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUM( ISNULL( ( SELECT CASE WHEN ( ( CONVERT(CHAR(8),KMM103.KMM103_PAY_DATE,112) &lt; &quot;YYYYMMDD&quot; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND KMM103.KMM103_PAY_STATUS &lt;&gt; &quot;1&quot; )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THEN KMM103.KMM103_PAY_AMT ELSE 0 END <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM KMM103<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE ( KMM103.KMM103_YY = KMM102.KMM102_YY )&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND ( KMM103.KMM103_BGT_KIND = KMM102.KMM102_BGT_KIND )&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND ( KMM103.KMM103_CASE_NO = KMM102.KMM102_CASE_NO ) ),0 ) ) AS AMT04&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; FROM KMM102,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KMM101&nbsp; <br />&nbsp;&nbsp; WHERE ( KMM102.KMM102_YY = &quot;YYY&quot; ) AND <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( KMM102.KMM102_BGT_KIND = &quot;1&quot; ) AND <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( KMM101.KMM101_YY =* KMM102.KMM102_YY ) AND <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( KMM101.KMM101_BGT_KIND =* KMM102.KMM102_BGT_KIND ) AND <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( KMM101.KMM101_BGT_TYPE =* KMM102.KMM102_BGT_TYPE )<br />GROUP BY SUBSTRING( KMM102.KMM102_BGT_TYPE,1,4 ),&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBSTRING( KMM102.KMM102_BGT_TYPE,3,2 ),&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBSTRING( KMM102.KMM102_BGT_TYPE,1,2 )&nbsp;&nbsp; <br />ORDER BY BGT_CLASS ASC,&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGT_TYPE DESC&nbsp; <br />;<br />我这条如果只给10分是不是太少了！<br />大多数用select可能遇到的都遇到了！ <br />bbs_delphi (2001-12-17 17:28) <br />gz <br />Zane (2001-12-17 17:29) <br />具体问题，具体分析 <br />坛子 (2001-12-17 17:33) <br />Advanced SQL Code Collection v1.2.0&nbsp;&nbsp; </p>
<p>Powerful editor that enables you to write your SQL scripts efficiently. It includes SQL <br />syntax highlighting, large base of SQL code templates, power search engine and convenient <br />bookmarks <br />风中流云 (2001-12-17 17:52) <br />agree zane <br />kals (2001-12-17 19:15) <br />一条两百分还差不多 <br />sxbing (2001-12-17 23:4) <br />select * from * <br />hwchen (2001-12-17 23:20) <br />select * into #tmp from *<br />drop #tmp <br />marknew (2001-12-18 9:6) <br />select * from *&nbsp;&nbsp; --》这是什么东东呀?乱讲.<br />看下我的存贮过程吧，里面还有很多技巧.<br />CREATE PROCEDURE PickDelta<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @pick_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(14),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @prepare_by&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(20),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @lcInitShipMaxNo&nbsp; varchar(20),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @lcInitSalesMaxNo varchar(20),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @ship_date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datetime,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @GenNewSales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(200)='' output,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @GenNewShips&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(200)='' output,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Have_ship&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean=0 output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />AS<br />declare @affect_row integer,@temp_store_qty&nbsp; integer<br />declare @DtempSeq_no tinyint,@Dtempproduct_code char(10),@Dtempvdr_id char(4),@Dtempstore_id char(6),@Dtempship_qty int<br />declare @i tinyint,@err_msg varchar(200),@Err_salesTitle varchar(100),@Have_LessSale&nbsp; bit<br />declare @c_id char(8),@tran_ltd varchar(80),@rec_acc_status char(1)<br />declare @TempStr varchar(20)<br />select&nbsp; @affect_row=0<br />select&nbsp; @Have_ship=0<br />select&nbsp; @i=0<br />SET NOCOUNT ON<br />if exists (select * from tempdb.dbo.sysobjects where name =&quot;##temp_store&quot;) <br />begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drop table ##temp_store<br />end <br />--得到本张检货单用到的所有的配件的库存临时表##temp_store<br />select * into ##temp_store from info_part_store where product_code+vdr_id+store_id in (select product_code+vdr_id+store_id <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from pick_detail where <a href="mailto:pick_num=@pick_num">pick_num=@pick_num</a>)<br />if @@rowcount&lt;=0 <br />begin<br />&nbsp;&nbsp; raiserror('在库存中没有找到任何配件,请确认这张捡货单是否有效',16,1)<br />&nbsp;&nbsp; return<br />end<br />begin transaction&nbsp;&nbsp; <br />--定义所有客户游标cursor_client<br />select cursor_status('local','cursor_client')<br />if cursor_status('local','cursor_client')&gt;0<br />begin<br />&nbsp;&nbsp; CLOSE cursor_client<br />&nbsp;&nbsp; DEALLOCATE cursor_client<br />end<br />declare cursor_client Cursor local For<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select distinct a.c_id,isnull(b.tran_ltd,'') as tran_ltd,isnull(b.rec_acc_status,'') as rec_acc_status<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from pick_detail a left join sales_title b on b.sales_no=a.sales_no where <a href="mailto:a.pick_num=@pick_num">a.pick_num=@pick_num</a><br />Open cursor_client<br />-- 取出一个客户<br />Fetch Next From cursor_client into&nbsp;&nbsp; @c_id,@tran_ltd,@rec_acc_status <br />While @@Fetch_Status=0<br />begin<br />&nbsp;&nbsp; --依据每个不同的客户生成新的出库单&nbsp; <br />&nbsp;&nbsp; if exists (select * from tempdb.dbo.sysobjects where name =&quot;##temp_pick&quot;) <br />&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drop table ##temp_pick<br />&nbsp;&nbsp; end <br />&nbsp;&nbsp; --生成临时表的序号无论库存够与否都要生成出库单,如果所有对应的库存都是0或者没有找到对应的库位则不生成<br />&nbsp;&nbsp; select a.pick_num,a.seq_no into ##temp_pick from pick_detail a&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left join info_part_store b on b.product_code=a.product_code and b.store_id=a.store_id and b.vdr_id=a.vdr_id<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:pick_num=@pick_num">pick_num=@pick_num</a> and <a href="mailto:a.c_id=@c_id">a.c_id=@c_id</a>&nbsp; and a.ship_qty&gt;0 and b.store_qty&gt;0<br />&nbsp;&nbsp; --如果有数据可以生成出库单的话<br />&nbsp;&nbsp; if @@rowcount&gt;0 <br />&nbsp;&nbsp; begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @Have_Ship=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --有数据可以生成出库单<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --定义当前客户的临时游标<br />&nbsp;&nbsp;&nbsp;&nbsp; if cursor_status('local','cursor_pick_detail')&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE cursor_pick_detail<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE cursor_pick_detail<br />&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Declare cursor_pick_detail Cursor local For<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select seq_no,product_code,vdr_id,store_id,ship_qty from pick_detail where <a href="mailto:pick_num=@pick_num">pick_num=@pick_num</a> and <a href="mailto:c_id=@c_id">c_id=@c_id</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; order by product_code,vdr_id,store_id<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open cursor_pick_detail<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --取出每一行的检货值<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fetch Next From cursor_pick_detail&nbsp; into&nbsp; @DtempSeq_no,@Dtempproduct_code,@Dtempvdr_id,@Dtempstore_id,@Dtempship_qty<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; While @@Fetch_Status=0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --得到对应的库存数量<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @temp_store_qty=(select top 1 store_qty from ##temp_store <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:product_code=@DtempProduct_code">product_code=@DtempProduct_code</a> and <a href="mailto:vdr_id=@Dtempvdr_id">vdr_id=@Dtempvdr_id</a> and <a href="mailto:store_id=@Dtempstore_id">store_id=@Dtempstore_id</a>) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --库存数量不为空<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @temp_store_qty is not null and @temp_store_qty&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --生成出库单明细资料&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @i=@i+1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert ship_detail select @lcInitShipMaxNo,@i,a.product_code,a.vdr_id,a.vdr_short,a.chinese_name,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.meter_unit,a.model_no,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when a.ship_qty&gt;@temp_store_qty then @temp_store_qty<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else a.ship_qty<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.ref_sale_price,a.store_id,0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '检货单号:'+a.pick_num+'行号:'+convert(varchar(10),a.seq_no) from&nbsp; pick_detail a <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left join info_moto_part&nbsp; b on b.product_code=a.product_code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where&nbsp; <a href="mailto:a.pick_num=@pick_num">a.pick_num=@pick_num</a> and <a href="mailto:a.seq_no=@DtempSeq_No">a.seq_no=@DtempSeq_No</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @@error&lt;&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @Err_msg=&quot;生成的出库单&quot;<a href="mailto:+@lcInitShipMaxNo">+@lcInitShipMaxNo</a>+&quot;明细时出错&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raiserror(@Err_msg,16,1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rollback transaction<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --修改对应订单的完成数量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update sales_detail set cmp_qty=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when b.ship_qty&gt;@temp_store_qty then @temp_store_qty<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else b.ship_qty<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from sales_detail a,pick_detail b where b.sales_no=a.sales_no and b.sales_seq_no=a.seq_no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end--处理当前客户每一行的捡货数量<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fetch Next From cursor_pick_detail into&nbsp; @DtempSeq_no,@Dtempproduct_code,@Dtempvdr_id,@Dtempstore_id,@Dtempship_qty<br />&nbsp;&nbsp;&nbsp;&nbsp; end--得到当前客户下一行的捡货数据<br />&nbsp;&nbsp;&nbsp;&nbsp; --生成出库单标题资料&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; if @Have_Ship=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --定义所有订单号游标cursor_sales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declare @AllSalesNo varchar(300)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declare @DtempSalesNo varchar(20)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select&nbsp; @AllSalesNo=''<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cursor_status('local','cursor_sales')&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE cursor_sales&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE cursor_sales&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declare cursor_sales&nbsp;&nbsp; Cursor local For&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select distinct sales_no from pick_detail where <a href="mailto:pick_num=@pick_num">pick_num=@pick_num</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open cursor_sales<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fetch Next From cursor_sales&nbsp; into&nbsp; @DtempSalesNo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; While @@Fetch_Status=0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @AllSalesNo='' <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select&nbsp; @AllSalesNo= &quot;'&quot;<a href="mailto:+@DtempSalesNo+&quot;'">+@DtempSalesNo+&quot;'</a>&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select&nbsp; @AllSalesNo= &quot;'&quot;<a href="mailto:+@AllSalesNo+&quot;',&quot;+@DtempSalesNo">+@AllSalesNo+&quot;',&quot;+@DtempSalesNo</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fetch Next From cursor_sales&nbsp; into&nbsp; @DtempSalesNo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE cursor_sales&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEALLOCATE cursor_sales&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert into ship_title(flow_num,ship_num,ship_date,c_id,tran_ltd,ship_type_id,rec_acc_status,ship_status,prepare_by,remark,sales_no) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values(@pick_num,@lcInitShipMaxNo,@ship_Date,@c_id,@tran_ltd,'00',@rec_acc_status,'未审',@prepare_by,'检货单号:'+@pick_num,@AllSalesNo)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @@error&lt;&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @Err_msg=&quot;生成的出库单&quot;<a href="mailto:+@lcInitShipMaxNo">+@lcInitShipMaxNo</a>+&quot;标题时出错&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raiserror(@Err_msg,16,1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rollback transaction<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @GenNewShips=@GenNewShips+char(13)+@lcInitShipMaxNo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @TempStr=substring(@lcInitShipMaxNo,1,8)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @lcInitShipMaxNo=convert(int,substring(@lcInitShipMaxNo,9,4))+1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @lcInitShipMaxNo=@TempStr+replicate(&quot;0&quot;,4-len(convert(varchar(10),@lcInitShipMaxNo)))+convert(char(4),@lcInitShipMaxNo)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end --处理当前客户的捡货出库情况<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --依据每个不同的客户生成新的缺货订单 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if exists (select * from tempdb.dbo.sysobjects where name =&quot;##temp_sales&quot;) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drop table ##temp_sales<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @lcInitSalesMaxNo as sales_no,IDENTITY(int,1,1) as seq_no,a.product_code,a.vdr_id,a.vdr_short,a.chinese_name,a.meter_unit,a.model_no,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abs(isnull(b.store_qty,0)-sum(ship_qty)) as sales_qty,0 as cmp_qty,'缺货检货单;'+a.pick_num as remark into ##temp_sales from pick_detail a<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left join ##temp_store b on b.product_code=a.product_code and b.vdr_id=a.vdr_id and b.store_id=a.store_id<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where <a href="mailto:a.pick_num=@pick_num">a.pick_num=@pick_num</a> and <a href="mailto:c_id=@c_id">c_id=@c_id</a> group by a.product_code,a.chinese_name,a.meter_unit,a.model_no,a.vdr_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.vdr_short,b.store_qty,a.pick_num having isnull(b.store_qty,0)-sum(a.ship_qty)&lt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @@rowcount&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select&nbsp; @Have_LessSale=1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert&nbsp; sales_detail select * from ##temp_sales<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @@error&lt;&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @Err_salesTitle =&quot;生成缺货订单的标题&quot;<a href="mailto:+@lcInitSalesMaxNo">+@lcInitSalesMaxNo</a>+&quot;出错&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raiserror(@Err_salesTitle,16,1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rollback transaction<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert&nbsp; into sales_title(sales_no,c_id,c_short,sales_date,ship_type_id,po_status,remark) select <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @lcInitSalesMaxNo,@c_id,c_short,getdate(),'00','未完','由检货单<a href="mailto:'+@pick_num+'">'+@pick_num+'</a>生成' from info_client where <a href="mailto:c_id=@c_id">c_id=@c_id</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if @@error&lt;&gt;0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @Err_salesTitle =&quot;生成缺货订单的明细&quot;<a href="mailto:+@lcInitSalesMaxNo">+@lcInitSalesMaxNo</a>+&quot;出错&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raiserror(@Err_salesTitle,16,1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rollback transaction<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @GenNewSales=@GenNewSales+char(13)+@lcInitSalesMaxNo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @TempStr=substring(@lcInitSalesMaxNo,1,8)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @lcInitSalesMaxNo=convert(int,substring(@lcInitSalesMaxNo,9,4))+1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @lcInitSalesMaxNo=@TempStr+replicate(&quot;0&quot;,4-len(convert(varchar(10),@lcInitSalesMaxNo)))+convert(char(4),@lcInitSalesMaxNo)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @lcInitSalesMaxNo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --依据每个不同的客户生成新的缺货订单 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --修改临时表的对应的配件的库存数量<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update ##temp_store set store_qty=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when isnull(b.ship_qty,0)&gt;store_qty then 0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else store_qty-isnull(b.ship_qty,0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from ##temp_store a<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left join pick_detail b on b.product_code=a.product_code and b.vdr_id=a.vdr_id and b.store_id=a.store_id&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and <a href="mailto:b.pick_num=@pick_num">b.pick_num=@pick_num</a> and <a href="mailto:b.c_id=@c_id">b.c_id=@c_id</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; Fetch Next From cursor_client into&nbsp; @c_id,@tran_ltd,@rec_acc_status<br />end-- 处理下一个客户 <br />&nbsp;--修改实际库存数量<br />update info_part_store set store_qty=isnull(b.store_qty,0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from&nbsp; info_part_store a,##temp_store b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where b.product_code=a.product_code and b.vdr_id=a.vdr_id and b.store_id=a.store_id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />--修改相应的订单状态<br />Update sales_title set po_status=&quot;出库&quot; where sales_no in<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (select distinct sales_no from pick_detail where <a href="mailto:pick_num=@pick_num">pick_num=@pick_num</a>)<br />--修改检货单状态<br />update pick_title set pick_status=&quot;审核&quot; where <a href="mailto:pick_num=@pick_num">pick_num=@pick_num</a><br />if cursor_status('local','cursor_client')&gt;0<br />begin<br />&nbsp;&nbsp; CLOSE cursor_client<br />&nbsp;&nbsp; DEALLOCATE cursor_client<br />end<br />if cursor_status('local','cursor_pick_detail')&gt;0<br />begin<br />&nbsp;&nbsp; CLOSE cursor_pick_detail<br />&nbsp;&nbsp; DEALLOCATE cursor_pick_detail<br />end<br />commit transaction <br />浩毛 (2001-12-18 9:18) <br />太多了<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_单位基本情况表'))<br />&nbsp; drop table dbo.jltmp_单位基本情况表<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_单位基本情况表2'))<br />&nbsp; drop table dbo.jltmp_单位基本情况表2<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_系统单位类别字典表'))<br />&nbsp; drop table dbo.jltmp_系统单位类别字典表<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_系统经济性质字典表'))<br />&nbsp; drop table dbo.jltmp_系统经济性质字典表<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_系统片区字典表'))<br />&nbsp; drop table dbo.jltmp_系统片区字典表<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_IncreNumber'))<br />&nbsp; drop function dbo.jltmp_IncreNumber<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_整理数据'))<br />&nbsp; drop procedure dbo.jltmp_整理数据<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_整理数据2'))<br />&nbsp; drop procedure dbo.jltmp_整理数据2<br />if exists (select * from dbo.sysobjects where id = object_id('jltmp_添加数据'))<br />&nbsp; drop procedure dbo.jltmp_添加数据<br />if exists (select * from dbo.sysobjects where id = object_id('dbo.jltmp_许可证编号转换'))<br />drop function dbo.jltmp_许可证编号转换<br />GO</p>
<p>create function dbo.jltmp_许可证编号转换<br />(<br />&nbsp; @psNumber varchar(100),<br />&nbsp; @len int <br />)<br />RETURNS varchar(100) AS<br />BEGIN <br />declare @sNewNumber varchar(100),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @iPos int<br />&nbsp;if @psNumber is null select @sNewNumber=null --返回null<br />&nbsp; else <br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; select @psNumber=ltrim(rtrim(@psNumber))<br />&nbsp;&nbsp;&nbsp; select @iPos=len(@psNumber)<br />&nbsp;&nbsp;&nbsp; --小于等于10为的许可证编码不变<br />if @iPos=0 select @sNewNumber=null --空格返回null<br />else begin<br />&nbsp;&nbsp;&nbsp;&nbsp; if @iPos&lt;=10 select @sNewNumber=@psNumber<br />&nbsp;&nbsp;&nbsp;&nbsp; else begin <br />select @sNewNumber=substring(@psNumber,(@len+1),(@iPos-@len))<br />if len(ltrim(rtrim(@sNewNumber)))&lt;&gt;@iPos-@len select @sNewNumber=null<br />&nbsp;&nbsp;&nbsp;&nbsp; end<br />end<br />&nbsp; end <br />&nbsp; return @sNewNumber<br />END<br />GO</p>
<p>create table dbo.jltmp_单位基本情况表<br />(<br />&nbsp; 申请编号 varchar(40) null,<br />&nbsp; 单位名称 varchar(100) null,<br />&nbsp; 单位类别 varchar(60) null,<br />&nbsp; 经济性质 varchar(60) null,<br />&nbsp; 地址 varchar(100) null,<br />&nbsp; 电话 varchar(60) null,<br />&nbsp; 法人或法人代表 varchar(60) null,<br />&nbsp;-- 负责人 varchar(60) null,<br />&nbsp; 经营范围 varchar(80) null,<br />&nbsp; 主管部门 varchar(60) null,<br />&nbsp; 职工人数 int null,<br />&nbsp; 从业人员数 int null,<br />&nbsp; 建档日期 datetime null,<br />&nbsp; 卫生许可证号 varchar(60) null,<br />&nbsp; 卫生卡号 varchar(60) null,<br />&nbsp; 片区 varchar(60) null,<br />&nbsp; 操作日期 datetime null,<br />&nbsp; 状态 varchar(60) null,<br />&nbsp; 年度评价 varchar(255) null,<br />&nbsp; 应体检日期 datetime null,<br />&nbsp; 下次定期监测日期 datetime null,<br />&nbsp; 档案编号 varchar(60) null,<br />&nbsp; 卫生种类 varchar(60) null,<br />&nbsp; 助记符 varchar(60) null,<br />&nbsp; 有效开始日期 datetime null,<br />&nbsp; 有效截止日期 datetime null,<br />&nbsp; 最后复验日期 datetime null<br />)</p>
<p>create table dbo.jltmp_单位基本情况表2<br />(<br />申请编号 UDT_申请编号 not null,<br />档案编号 UDT_档案编号 not null,<br />单位名称 varchar(80) null,<br />法人代表 varchar(20) null,<br />经济性质 varchar(20) null,<br />片区 varchar(20) null,<br />地址 varchar(80) null,<br />街道 varchar(20) null,<br />电话 varchar(20) null,<br />职工人数 int null,<br />从业人数 int null,<br />卫生种类 varchar(10) null,<br />行业类别 varchar(40) null,<br />经营内容 varchar(80) null,<br />主管单位 varchar(60) null,<br />应体检人数 int null,<br />已体检人数 int null,<br />卫生许可证号 char(10) null,<br />助记符 varchar(40) null,<br />建档日期 datetime not null,<br />有效开始日期 datetime null,<br />有效截止日期 datetime null,<br />最后复验日期 datetime null<br />)</p>
<p><br />create table dbo.jltmp_系统单位类别字典表<br />(<br />&nbsp; 编号 varchar(20) null,<br />&nbsp; 内容 varchar(60) null,<br />&nbsp; 卫生种类 varchar(20) null<br />)<br />create table dbo.jltmp_系统经济性质字典表<br />(<br />&nbsp; 编号 varchar(20) null,<br />&nbsp; 内容 varchar(60) null<br />)<br />create table dbo.jltmp_系统片区字典表<br />(<br />&nbsp; 编号 varchar(20) null,<br />&nbsp; 内容 varchar(60) null<br />)<br />GO</p>
<p><br />create function dbo.jltmp_IncreNumber<br />(<br />&nbsp; @psNumber varchar(100)<br />)<br />RETURNS varchar(100) AS<br />BEGIN </p>
<p>&nbsp; declare @sNewNumber varchar(100),@iPos int</p>
<p>&nbsp; if @psNumber is null select @sNewNumber='01'<br />&nbsp; else begin<br />&nbsp;&nbsp;&nbsp; select @iPos=len(@psNumber)<br />&nbsp;&nbsp;&nbsp; while @iPos&gt;0 and substring(@psNumber,@iPos,1)&gt;='0' and substring(@psNumber,@iPos,1)&lt;='9'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @iPos=@iPos - 1<br />&nbsp;&nbsp;&nbsp; if @iPos&gt;0 begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @sNewNumber=substring(@psNumber,1,@iPos)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select @psNumber=substring(@psNumber,@iPos+1,len(@psNumber) - @iPos) end<br />&nbsp;&nbsp;&nbsp; else select @sNewNumber=''<br />&nbsp;&nbsp;&nbsp; select @iPos=len(@psNumber)<br />&nbsp;&nbsp;&nbsp; select @psNumber=rtrim(ltrim(str(convert(int, @psNumber)+1)))<br />&nbsp;&nbsp;&nbsp; -- @iPos may &lt; len(@psNumber), for example, @psNumber = '9' + 1 -&gt; '10'<br />&nbsp;&nbsp;&nbsp; --because replace(' ',space(&lt;=0), '0')=' ', so<br />&nbsp;&nbsp;&nbsp; if @iPos&lt;=len(@psNumber) select @sNewNumber=@sNewNumber+@psNumber<br />&nbsp;&nbsp;&nbsp; else select @sNewNumber=@sNewNumber+replace(space(@iPos -len(@psNumber)),' ', '0')+@psNumber<br />&nbsp; end<br />&nbsp; return @sNewNumber<br />END<br />GO</p>
<p>&nbsp;</p>
<p>create procedure dbo.jltmp_整理数据2 as<br />BEGIN <br />set nocount on</p>
<p>&nbsp; --添加字典数据<br />&nbsp; delete jltmp_系统单位类别字典表 <br />&nbsp; insert into jltmp_系统单位类别字典表 select distinct null,单位类别,卫生种类 from jltmp_单位基本情况表 where 单位类别 is not null<br />&nbsp; delete jltmp_系统片区字典表<br />&nbsp; insert into jltmp_系统片区字典表 select distinct null,片区 from jltmp_单位基本情况表 where 片区 is not null<br />&nbsp; delete jltmp_系统经济性质字典表<br />&nbsp; insert into jltmp_系统经济性质字典表 select distinct null,经济性质 from jltmp_单位基本情况表 where 经济性质 is not null</p>
<p>&nbsp; --经济性质升级与防疫26一致<br />&nbsp; update jltmp_单位基本情况表 set 经济性质 = case<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when 经济性质 in ('国有','集体','私营') then 经济性质 + '企业'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when 经济性质 = '股份制' then '股份企业'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 经济性质<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; update jltmp_系统经济性质字典表 set 内容 = case<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when 内容 in ('国有','集体','私营') then 内容 + '企业'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when 内容 = '股份制' then '股份企业'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 内容<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp; --升级单位类别<br />&nbsp; update jltmp_单位基本情况表 <br />set 单位类别 = case<br />when 单位类别 ='糕点 蜜饯' then '糕点,蜜饯'<br />else replace(单位类别,' ','')<br />&nbsp; end<br />&nbsp; update jltmp_系统单位类别字典表 <br />set 内容 = case<br />when 内容 = '糕点 蜜饯' then '糕点,蜜饯'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else replace(内容,' ','')<br />&nbsp; end</p>
<p>--select distinct 单位类别 from jltmp_单位基本情况表<br />END<br />GO</p>
<p><br />create procedure dbo.jltmp_整理数据 as<br />BEGIN <br />set nocount on<br />&nbsp; --删除重复单位<br />&nbsp; delete jltmp_单位基本情况表 from jltmp_单位基本情况表 a,单位档案_单位基本信息表 b<br />&nbsp;&nbsp;&nbsp; where a.单位名称=b.单位名称 and a.片区=b.片区 and a.卫生种类=b.卫生种类 and a.经济性质=b.经济性质 and a.单位类别=b.行业类别</p>
<p>&nbsp; --删除已存在的单位类别<br />&nbsp; delete jltmp_系统单位类别字典表 from jltmp_系统单位类别字典表 a,系统管理_字典_字典内容表 b<br />&nbsp;&nbsp;&nbsp; where a.内容=b.名称 and b.ID=dbo.系统管理_获取字典类别ID('行业属性字典') and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.Parent = (select InnerID from 系统管理_字典_字典内容表<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where ID=dbo.系统管理_获取字典类别ID('行业属性字典') and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 名称=a.卫生种类 and Parent=0)<br />&nbsp; --删除已存在的片区<br />&nbsp; delete jltmp_系统片区字典表 from jltmp_系统片区字典表 a,系统管理_字典_字典内容表 b<br />&nbsp;&nbsp;&nbsp; where a.内容=b.名称 and b.ID=dbo.系统管理_获取字典类别ID('片区街道字典') and Parent=0<br />&nbsp; --删除已存在的经济性质<br />&nbsp; delete jltmp_系统经济性质字典表 from jltmp_系统经济性质字典表 a,系统管理_字典_字典内容表 b<br />&nbsp;&nbsp;&nbsp; where a.内容=b.名称 and b.ID=dbo.系统管理_获取字典类别ID('经济性质字典') and Parent=0</p>
<p>&nbsp; --处理片区为null的单位<br />&nbsp; if exists (select * from jltmp_单位基本情况表 where 片区 is null) <br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; update jltmp_单位基本情况表 <br />set 片区 ='&lt;未定&gt;' <br />where 片区 is null<br />&nbsp;&nbsp;&nbsp; insert into jltmp_系统片区字典表 values(null,'&lt;未定&gt;') <br />&nbsp; end<br />&nbsp;&nbsp;&nbsp; --处理经济性质为null的单位<br />&nbsp; if exists (select * from jltmp_单位基本情况表 where 经济性质 is null) <br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; update jltmp_单位基本情况表 <br />set 经济性质 ='&lt;未定&gt;' <br />where 经济性质 is null<br />&nbsp;&nbsp;&nbsp; insert into jltmp_系统经济性质字典表 values(null,'&lt;未定&gt;') <br />&nbsp; end<br />&nbsp; --处理建档日期为null的单位,更改为当前日期<br />&nbsp; if exists (select * from jltmp_单位基本情况表 where 建档日期 is null)<br />&nbsp; begin<br />&nbsp; update jltmp_单位基本情况表<br />set 建档日期=getdate() <br />where 建档日期 is null<br />&nbsp; end<br />&nbsp; <br />END<br />GO</p>
<p>create procedure dbo.jltmp_添加数据 as<br />BEGIN <br />set nocount on<br />declare <br />&nbsp; @申请编号 varchar(40),@单位名称 varchar(100),@单位类别 varchar(60),@经济性质 varchar(60),<br />&nbsp; @地址 varchar(100),@电话 varchar(60),@法人或法人代表 varchar(60),@负责人 varchar(60),<br />&nbsp; @经营范围 varchar(60),@主管部门 varchar(60),@职工人数 int,@从业人员数 int,<br />&nbsp; @建档日期 datetime,@卫生许可证号 varchar(60),@片区 varchar(60),@档案编号 varchar(60),<br />&nbsp; @卫生种类 varchar(60),@助记符 varchar(60),@编号 varchar(60),@内容 varchar(60),<br />&nbsp; @ID varchar(20),@InnerID int,<br />&nbsp; @有效开始日期 datetime,<br />&nbsp; @有效截止日期 datetime,<br />&nbsp; @最后复验日期 datetime</p>
<p>--逐个添加经济性质<br />declare cur经济性质 cursor for select distinct 内容 from jltmp_系统经济性质字典表<br />open cur经济性质<br />fetch cur经济性质 into @内容<br />select @ID=dbo.系统管理_获取字典类别ID('经济性质字典')<br />select @编号=isnull(max(编号),'00') from 系统管理_字典_字典内容表 where <a href="mailto:ID=@ID">ID=@ID</a><br />while @@fetch_status=0 begin<br />&nbsp; select @编号=dbo.jltmp_IncreNumber(@编号)<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号,@内容,'','&lt;防疫25升级到26单位档案导入&gt;',0)<br />&nbsp; fetch cur经济性质 into @内容<br />end<br />deallocate cur经济性质<br />--逐个添加片区<br />declare cur片区 cursor for select distinct 内容 from jltmp_系统片区字典表<br />open cur片区<br />fetch cur片区 into @内容<br />select @ID=dbo.系统管理_获取字典类别ID('片区街道字典')<br />select @编号=isnull(max(编号),'00') from 系统管理_字典_字典内容表 where <a href="mailto:ID=@ID">ID=@ID</a><br />while @@fetch_status=0 begin<br />&nbsp; select @编号=dbo.jltmp_IncreNumber(@编号)<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号,@内容,'','&lt;防疫25升级到26单位档案导入&gt;',0)<br />&nbsp; select @InnerID=max(InnerID) from 系统管理_字典_字典内容表<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号+'01','&lt;未定&gt;','','&lt;防疫25升级到26单位档案导入&gt;',@InnerID)<br />&nbsp; fetch cur片区 into @内容<br />end<br />deallocate cur片区</p>
<p>--逐个添加单位类别<br />declare cur单位类别 cursor for select distinct 内容,卫生种类 from jltmp_系统单位类别字典表<br />open cur单位类别<br />fetch cur单位类别 into @内容,@卫生种类<br />select @ID=dbo.系统管理_获取字典类别ID('行业属性字典')<br />while @@fetch_status=0 begin<br />&nbsp; select @InnerID=InnerID from 系统管理_字典_字典内容表<br />&nbsp;&nbsp; where <a href="mailto:ID=@ID">ID=@ID</a> and 名称=@卫生种类 and Parent=0<br />&nbsp; select @编号=dbo.jltmp_IncreNumber(isnull(max(b.编号),max(a.编号)+'00'))<br />&nbsp;&nbsp;&nbsp; from 系统管理_字典_字典内容表 a left join 系统管理_字典_字典内容表 b on b.Parent = a.InnerID<br />&nbsp;&nbsp; where <a href="mailto:a.ID=@ID">a.ID=@ID</a> and a.名称=@卫生种类 and a.Parent=0<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号,@内容,'','&lt;防疫25升级到26单位档案导入&gt;',@InnerID)<br />&nbsp; select @InnerID=max(InnerID) from 系统管理_字典_字典内容表<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号+'0','单位类别','','&lt;防疫25升级到26单位档案导入&gt;',@InnerID)<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号+'1','经营形式','','&lt;防疫25升级到26单位档案导入&gt;',@InnerID)<br />&nbsp; insert into 系统管理_字典_字典内容表 values(@ID,@编号+'2','许可项目','','&lt;防疫25升级到26单位档案导入&gt;',@InnerID)<br />&nbsp; fetch cur单位类别 into @内容,@卫生种类<br />end<br />deallocate cur单位类别</p>
<p>--逐个添加单位信息<br />declare cur单位基本情况表 cursor for<br />&nbsp; select distinct 单位名称,单位类别,经济性质,地址,电话,法人或法人代表,经营范围,主管部门,建档日期,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 职工人数,从业人员数,卫生许可证号,片区,卫生种类,助记符,有效开始日期,有效截止日期,最后复验日期<br />&nbsp;&nbsp;&nbsp; from jltmp_单位基本情况表<br />open cur单位基本情况表<br />fetch cur单位基本情况表 into @单位名称,@单位类别,@经济性质,@地址,@电话,@法人或法人代表,@经营范围,@主管部门,<br />&nbsp; @建档日期,@职工人数,@从业人员数,@卫生许可证号,@片区,@卫生种类,@助记符,@有效开始日期,@有效截止日期,@最后复验日期<br />while @@fetch_status=0 begin</p>
<p>&nbsp; exec 系统管理_返回编号流水号 '单位档案管理','申请编号',@申请编号 output,Null</p>
<p>&nbsp; select @编号=编号 from 系统管理_字典_字典内容表 a,系统管理_字典_字典表列表 b<br />&nbsp;&nbsp; where a.ID=b.ID and b.名称='行业属性字典' and a.名称=@卫生种类</p>
<p>&nbsp; --以下暂时用 @编号 存储卫生种类的ID<br />&nbsp; --参考存储过程 单位档案_生成档案编号<br />&nbsp; declare @代号 char(5)<br />&nbsp; declare @编号类型 varchar(10)<br />&nbsp; if exists(select * from dbo.单位档案_档案编号使用情况表 where substring(档案编号,1,1) = @编号)<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; select @档案编号 =min(CONVERT(int,档案编号)) from dbo.单位档案_档案编号使用情况表<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with (holdlock)<br />&nbsp;&nbsp;&nbsp;&nbsp; where substring(档案编号,1,1) = @编号<br />&nbsp;&nbsp;&nbsp; delete from dbo.单位档案_档案编号使用情况表 where 档案编号 = @档案编号<br />&nbsp; end<br />&nbsp; else<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; set @编号类型='档案编号' + @编号<br />&nbsp;&nbsp;&nbsp; exec 系统管理_返回编号流水号 '单位档案管理',@编号类型,@代号 output,null<br />&nbsp;&nbsp;&nbsp; set @档案编号 = @编号 + @代号 <br />&nbsp; end</p>
<p>&nbsp; insert into jltmp_单位基本情况表2(单位名称,行业类别,经济性质,地址,电话,法人代表,经营内容,主管单位,<br />&nbsp;&nbsp;&nbsp; 建档日期,职工人数,从业人数,卫生许可证号,片区,卫生种类,街道,申请编号,档案编号,助记符,应体检人数,已体检人数,有效开始日期,有效截止日期,最后复验日期)<br />&nbsp;&nbsp; values(@单位名称,@单位类别,@经济性质,@地址,@电话,@法人或法人代表,@经营范围,@主管部门,<br />&nbsp;&nbsp;&nbsp; @建档日期,@职工人数,@从业人员数,@卫生许可证号,@片区,@卫生种类,'&lt;未定&gt;',@申请编号,@档案编号,@助记符,0,0,@有效开始日期,@有效截止日期,@最后复验日期)&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp; fetch cur单位基本情况表 into @单位名称,@单位类别,@经济性质,@地址,@电话,@法人或法人代表,@经营范围,@主管部门,<br />&nbsp;&nbsp;&nbsp; @建档日期,@职工人数,@从业人员数,@卫生许可证号,@片区,@卫生种类,@助记符,@有效开始日期,@有效截止日期,@最后复验日期 <br />end<br />deallocate cur单位基本情况表</p>
<p>&nbsp; insert into 单位档案_单位基本信息表 <br />(单位名称,行业类别,经济性质,地址,电话,法人代表,经营内容,主管单位,<br />&nbsp;&nbsp;&nbsp; 建档日期,职工人数,从业人数,卫生许可证号,片区,卫生种类,街道,申请编号,档案编号,助记符,应体检人数,已体检人数)<br />&nbsp; select 单位名称,行业类别,经济性质,地址,电话,法人代表,经营内容,主管单位,<br />&nbsp;&nbsp;&nbsp; 建档日期,职工人数,从业人数,卫生许可证号,片区,卫生种类,街道,申请编号,档案编号,助记符,应体检人数,已体检人数<br />&nbsp; from jltmp_单位基本情况表2</p>
<p><br />END</p>
<p>--delete dbo.单位档案_单位基本信息表 <br />--delete dbo.许可证_使用信息表<br />--select a.申请编号,a.单位名称,a.卫生许可证号,a.卫生种类,a.建档日期,a.有效截止日期,a.有效开始日期,a.最后复验日期 from jltmp_单位基本情况表2 a where isnull(a.卫生许可证号,'')&lt;&gt;'' and a.申请编号 not in (select b.申请编号 from 许可证_使用信息表 b)<br />--select * from dbo.单位档案_单位基本信息表 <br />--select * from dbo.jltmp_单位基本情况表2 <br />浩毛 (2001-12-18 9:20) <br />还有，嘻嘻</p>
<p>SET QUOTED_IDENTIFIER OFF <br />GO<br />SET ANSI_NULLS ON <br />GO<br />CREATE&nbsp;&nbsp;&nbsp; PROCEDURE 检验管理_自动评价 <br />@p收检编号 VARCHAR ( 20 ) = '2001073101100003'<br />AS</p>
<p>set nocount on <br />declare @l返回值&nbsp;&nbsp; varchar(2000),<br />@l单一样品评价 varchar(500),<br />@l样品数 int,<br />@l合格数 int, /*某一样品检验为合格的项目数*/<br />@l不合格数 int, /*某一样品检验为不合格的项目数*/<br />@l检验项目数&nbsp;&nbsp; int, /*记录某单一样品的检验项目数*/<br />@li&nbsp; int,&nbsp; /*用于控制循环次数的变量*/<br />@lj&nbsp; int,&nbsp; /*用于控制循环次数的变量*/<br />&nbsp;&nbsp;&nbsp; @l检验结论 varchar(20)</p>
<p>/*建临时表并添入数据，用于记录本次收检的所有样品和每一样品的检验依据，检验结论。*/<br />select IDENTITY(int) as ID,a.样品名称,a.检验依据,a.检验结论,a.收检编号,a.样品系统编号<br />into #样品检验信息表<br />from 检验管理_收检样品信息表 a<br />where @p收检编号 = 收检编号</p>
<p>/*建临时表,用于记录样品的所有检验项目的检验结果信息.*/<br />create table #检验项目记录表(ID int IDENTITY,<br />收检编号 varchar(20),<br />样品系统编号 varchar(20),<br />项目名称 varchar(50),<br />单项结论 varchar(10))</p>
<p>select @li = 1, @l样品数 = max(ID),@l返回值 = '' from #样品检验信息表</p>
<p>while(@li &lt;= @l样品数)<br />begin<br />truncate table #检验项目记录表</p>
<p>/*取出并记录下当前样品的检验项目及其结论*/<br />insert into #检验项目记录表(收检编号,样品系统编号,项目名称,单项结论) <br />select a.收检编号,a.样品系统编号,c.名称 as 项目名称,a.单项结论<br />from 检验管理_样品检验项目结果表 a,#样品检验信息表 b,系统管理_检验项目字典视图 c<br />where a.收检编号 = b.收检编号 and<br />a.样品系统编号 = b.样品系统编号 and<br />a.检验项目编号 = c.编号 and<br />b.ID = @li <br />order by a.单项结论</p>
<p>select @lj = 1,<br />@l检验项目数 = max(ID)<br />from #检验项目记录表</p>
<p>/*检查是否所有的项目都已检验完成（已下检验结论）*/<br />set @l合格数 = (select count(*) from #检验项目记录表 where 单项结论 = '合格')<br />set @l不合格数 = (select count(*) from #检验项目记录表 where 单项结论 = '不合格')<br />if (@l合格数 + @l不合格数 != @l检验项目数)<br />begin<br />-- RAISERROR('检验还没完成，不能自动评价',16,1)<br />-- return -1<br />set @l合格数 = @l检验项目数 - @l不合格数<br />end</p>
<p>/*拼自动评价字串*/<br />select @l单一样品评价 = '依据&ldquo;' + 检验依据&nbsp; + '&rdquo;（标准、规范）,' + 样品名称 + '经检测，其中所检 '<br />from #样品检验信息表 where ID = @li</p>
<p>while(@lj &lt;= @l合格数)&nbsp; /*拼出合格的检验项目*/<br />begin <br />set @l单一样品评价 =ltrim(rtrim( @l单一样品评价)) + (select 项目名称 from #检验项目记录表 where @lj = ID)<br />&nbsp; + '，'</p>
<p>set @lj = @lj + 1<br />end</p>
<p>if(@l合格数 &gt; 0)<br />set @l单一样品评价 = left(@l单一样品评价,len(@l单一样品评价) - 1) + '等项符合标准，'</p>
<p>while(@lj &lt;= @l检验项目数)&nbsp;&nbsp; /*拼出不合格的检验项目*/<br />begin<br />set @l单一样品评价 = @l单一样品评价 + (select 项目名称 from #检验项目记录表 where @lj = ID)<br />&nbsp;+ convert(varchar(4),@lj) + '，'</p>
<p>set @lj = @lj + 1<br />end</p>
<p>if(@l不合格数 &gt; 0)<br />set @l单一样品评价 = left(@l单一样品评价,len(@l单一样品评价) - 1) + '等几项不符合标准，' </p>
<p>/*征对一个样品的所有检验项目下一个评价*/<br />set @l检验结论 = isnull((select 检验结论 from #样品检验信息表 where @li = ID),'合格')</p>
<p>if len(ltrim(@l检验结论)) = 0 <br />set @l检验结论 = '合格'<br />set @l单一样品评价 = @l单一样品评价 + '判为' + @l检验结论<br />&nbsp;+ '。' + char(13) + char(10) </p>
<p>set @l返回值 = @l返回值 + @l单一样品评价</p>
<p>set @li = @li + 1<br />end</p>
<p>/*删除用过的监时表*/</p>
<p>select @l返回值 as 检验评价</p>
<p><br />GO<br />SET QUOTED_IDENTIFIER OFF <br />GO<br />SET ANSI_NULLS ON <br />GO <br />zs (2001-12-18 9:30) <br />gz <br />cfx (2001-12-19 19:14) <br />ASC,min,max,<br />sunstring ,getdate, 还有好多的东西，<br />最好去搞本SQL <br />书去看看里面一般都有的 <br />//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br />保存 评价 游戏规则 免费注册&nbsp; 资料下载 关于本站&nbsp; </p>
<p><br />--------------------------------------------------------------------------------</p>
<p>大富翁论坛版权所有<br />&nbsp;KeyLife富翁笔记&nbsp; <br />作者: f_anny<br />标题: SQL中日期的处理 <br />关键字: 日期的处理 <br />分类: 个人专区 <br />密级: 公开 <br />(评分: , 回复: 0, 阅读: 114) ?? <br />通常，你需要获得当前日期和计算一些其他的日期，例如，你的程序可能需要判断一个月的第一天或者最后一天。你们大部分人大概都知道怎样把日期进行分割（年、月、日等），然后仅仅用分割出来的年、月、日等放在几个函数中计算出自己所需要的日期！在这篇文章里，我将告诉你如何使用DATEADD和DATEDIFF函数来计算出在你的程序中可能你要用到的一些不同日期。&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在使用本文中的例子之前，你必须注意以下的问题。大部分可能不是所有例子在不同的机器上执行的结果可能不一样，这完全由哪一天是一个星期的第一天这个设置决定。第一天（DATEFIRST）设定决定了你的系统使用哪一天作为一周的第一天。所有以下的例子都是以星期天作为一周的第一天来建立，也就是第一天设置为7。假如你的第一天设置不一样，你可能需要调整这些例子，使它和不同的第一天设置相符合。你可以通过@@DATEFIRST函数来检查第一天设置。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了理解这些例子，我们先复习一下DATEDIFF和DATEADD函数。DATEDIFF函数计算两个日期之间的小时、天、周、月、年等时间间隔总数。DATEADD函数计算一个日期通过给时间间隔加减来获得一个新的日期。要了解更多的DATEDIFF和DATEADD函数以及时间间隔可以阅读微软联机帮助。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用DATEDIFF和DATEADD函数来计算日期，和本来从当前日期转换到你需要的日期的考虑方法有点不同。你必须从时间间隔这个方面来考虑。比如，从当前日期到你要得到的日期之间有多少时间间隔，或者，从今天到某一天（比如1900-1-1）之间有多少时间间隔，等等。理解怎样着眼于时间间隔有助于你轻松的理解我的不同的日期计算例子。&nbsp;&nbsp; </p>
<p>一个月的第一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一个例子，我将告诉你如何从当前日期去这个月的最后一天。请注意：这个例子以及这篇文章中的其他例子都将只使用DATEDIFF和DATEADD函数来计算我们想要的日期。每一个例子都将通过计算但前的时间间隔，然后进行加减来得到想要计算的日期。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是计算一个月第一天的SQL&nbsp; 脚本：&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; DATEADD(mm,&nbsp; DATEDIFF(mm,0,getdate()),&nbsp; 0)&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把这个语句分开来看看它是如何工作的。最核心的函数是getdate()，大部分人都知道这个是返回当前的日期和时间的函数。下一个执行的函数DATEDIFF(mm,0,getdate())是计算当前日期和&ldquo;1900-01-01&nbsp; 00:00:00.000&rdquo;这个日期之间的月数。记住：时期和时间变量和毫秒一样是从&ldquo;1900-01-01&nbsp; 00:00:00.000&rdquo;开始计算的。这就是为什么你可以在DATEDIFF函数中指定第一个时间表达式为&ldquo;0&rdquo;。下一个函数是DATEADD，增加当前日期到&ldquo;1900-01-01&rdquo;的月数。通过增加预定义的日期&ldquo;1900-01-01&rdquo;和当前日期的月数，我们可以获得这个月的第一天。另外，计算出来的日期的时间部分将会是&ldquo;00:00:00.000&rdquo;。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个计算的技巧是先计算当前日期到&ldquo;1900-01-01&rdquo;的时间间隔数，然后把它加到&ldquo;1900-01-01&rdquo;上来获得特殊的日期，这个技巧可以用来计算很多不同的日期。下一个例子也是用这个技巧从当前日期来产生不同的日期。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp; <br />本周的星期一&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里我是用周(wk)的时间间隔来计算哪一天是本周的星期一。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; DATEADD(wk,&nbsp; DATEDIFF(wk,0,getdate()),&nbsp; 0)&nbsp;&nbsp; </p>
<p>一年的第一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在用年(yy)的时间间隔来显示这一年的第一天。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate()),&nbsp; 0)&nbsp;&nbsp; </p>
<p>季度的第一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假如你要计算这个季度的第一天，这个例子告诉你该如何做。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; DATEADD(qq,&nbsp; DATEDIFF(qq,0,getdate()),&nbsp; 0)&nbsp;&nbsp; </p>
<p>当天的半夜&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 曾经需要通过getdate()函数为了返回时间值截掉时间部分，就会考虑到当前日期是不是在半夜。假如这样，这个例子使用DATEDIFF和DATEADD函数来获得半夜的时间点。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; DATEADD(dd,&nbsp; DATEDIFF(dd,0,getdate()),&nbsp; 0)&nbsp;&nbsp; </p>
<p>深入DATEDIFF和DATEADD函数计算&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你可以明白，通过使用简单的DATEDIFF和DATEADD函数计算，你可以发现很多不同的可能有意义的日期。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 目前为止的所有例子只是仅仅计算当前的时间和&ldquo;1900-01-01&rdquo;之间的时间间隔数量，然后把它加到&ldquo;1900-01-01&rdquo;的时间间隔上来计算出日期。假定你修改时间间隔的数量，或者使用不同的时间间隔来调用DATEADD函数，或者减去时间间隔而不是增加，那么通过这些小的调整你可以发现和多不同的日期。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里有四个例子使用另外一个DATEADD函数来计算最后一天来分别替换DATEADD函数前后两个时间间隔。&nbsp;&nbsp; </p>
<p>上个月的最后一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是一个计算上个月最后一天的例子。它通过从一个月的最后一天这个例子上减去3毫秒来获得。有一点要记住，在Sql&nbsp; Server中时间是精确到3毫秒。这就是为什么我需要减去3毫秒来获得我要的日期和时间。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; dateadd(ms,-3,DATEADD(mm,&nbsp; DATEDIFF(mm,0,getdate()),&nbsp; 0))&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 计算出来的日期的时间部分包含了一个Sql&nbsp; Server可以记录的一天的最后时刻(&ldquo;23:59:59:997&rdquo;)的时间。&nbsp;&nbsp; </p>
<p>去年的最后一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 连接上面的例子，为了要得到去年的最后一天，你需要在今年的第一天上减去3毫秒。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; dateadd(ms,-3,DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate()),&nbsp; 0))&nbsp;&nbsp; </p>
<p>本月的最后一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，为了获得本月的最后一天，我需要稍微修改一下获得上个月的最后一天的语句。修改需要给用DATEDIFF比较当前日期和&ldquo;1900-01-01&rdquo;返回的时间间隔上加1。通过加1个月，我计算出下个月的第一天，然后减去3毫秒，这样就计算出了这个月的最后一天。这是计算本月最后一天的SQL脚本。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; dateadd(ms,-3,DATEADD(mm,&nbsp; DATEDIFF(m,0,getdate())+1,&nbsp; 0))&nbsp;&nbsp; </p>
<p>本年的最后一天&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你现在应该掌握这个的做法，这是计算本年最后一天脚本&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT&nbsp; dateadd(ms,-3,DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate())+1,&nbsp; 0))。&nbsp;&nbsp; </p>
<p>本月的第一个星期一&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 好了，现在是最后一个例子。这里我要计算这个月的第一个星期一。这是计算的脚本。&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select&nbsp; DATEADD(wk,&nbsp; DATEDIFF(wk,0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dateadd(dd,6-datepart(day,getdate()),getdate())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),&nbsp; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这个例子里，我使用了&ldquo;本周的星期一&rdquo;的脚本，并作了一点点修改。修改的部分是把原来脚本中&ldquo;getdate()&rdquo;部分替换成计算本月的第6天，在计算中用本月的第6天来替换当前日期使得计算可以获得这个月的第一个星期一。&nbsp;&nbsp; </p>
<p>总结&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我希望这些例子可以在你用DATEADD和DATEDIFF函数计算日期时给你一点启发。通过使用这个计算日期的时间间隔的数学方法，我发现为了显示两个日期之间间隔的有用历法是有价值的。注意，这只是计算出这些日期的一种方法。要牢记，还有很多方法可以得到相同的计算结果。假如你有其他的方法，那很不错，要是你没有，我希望这些例子可以给你一些启发，当你要用DATEADD和DATEDIFF函数计算你程序可能要用到的日期时。&nbsp;&nbsp; </p>
<p>---------------------------------------------------------------&nbsp;&nbsp; <br />附录，其他日期处理方法&nbsp;&nbsp; </p>
<p>1)去掉时分秒&nbsp;&nbsp; <br />declare&nbsp; @&nbsp; datetime&nbsp;&nbsp; <br />set&nbsp; @&nbsp; =&nbsp; getdate()&nbsp; --'2003-7-1&nbsp; 10:00:00'&nbsp;&nbsp; <br />SELECT&nbsp; @,DATEADD(day,&nbsp; DATEDIFF(day,0,@),&nbsp; 0)&nbsp;&nbsp; </p>
<p>2）显示星期几&nbsp;&nbsp; <br />select&nbsp; datename(weekday,getdate())&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>3）如何取得某个月的天数&nbsp;&nbsp; <br />declare&nbsp; @m&nbsp; int&nbsp;&nbsp; <br />set&nbsp; @m=2&nbsp; --月份&nbsp;&nbsp; <br />select&nbsp;&nbsp;&nbsp; datediff(day,'2003-'+cast(@m&nbsp; as&nbsp; varchar)+'-15'&nbsp; ,'2003-'+cast(@m+1&nbsp;&nbsp;&nbsp; as&nbsp; varchar)+'-15')&nbsp;&nbsp; <br />另外，取得本月天数&nbsp;&nbsp; <br />select&nbsp;&nbsp;&nbsp; datediff(day,cast(month(GetDate())&nbsp; as&nbsp; varchar)+'-'+cast(month(GetDate())&nbsp; as&nbsp; varchar)+'-15'&nbsp; ,cast(month(GetDate())&nbsp; as&nbsp; varchar)+'-'+cast(month(GetDate())+1&nbsp;&nbsp;&nbsp; as&nbsp; varchar)+'-15')&nbsp;&nbsp; <br />或者使用计算本月的最后一天的脚本，然后用DAY函数区最后一天&nbsp;&nbsp; <br />SELECT&nbsp; Day(dateadd(ms,-3,DATEADD(mm,&nbsp; DATEDIFF(m,0,getdate())+1,&nbsp; 0)))&nbsp;&nbsp; </p>
<p>4）判断是否闰年：&nbsp;&nbsp; <br />SELECT&nbsp; case&nbsp; day(dateadd(mm,&nbsp; 2,&nbsp; dateadd(ms,-3,DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate()),&nbsp; 0))))&nbsp; when&nbsp; 28&nbsp; then&nbsp; '平年'&nbsp; else&nbsp; '闰年'&nbsp; end&nbsp;&nbsp; <br />或者&nbsp;&nbsp; <br />select&nbsp; case&nbsp; datediff(day,datename(year,getdate())+'-02-01',dateadd(mm,1,datename(year,getdate())+'-02-01'))&nbsp;&nbsp; <br />when&nbsp; 28&nbsp; then&nbsp; '平年'&nbsp; else&nbsp; '闰年'&nbsp; end&nbsp;&nbsp; </p>
<p>5）一个季度多少天&nbsp;&nbsp; <br />declare&nbsp; @m&nbsp; tinyint,@time&nbsp; smalldatetime&nbsp;&nbsp; <br />select&nbsp; @m=month(getdate())&nbsp;&nbsp; <br />select&nbsp; @m=case&nbsp; when&nbsp; @m&nbsp; between&nbsp; 1&nbsp; and&nbsp; 3&nbsp; then&nbsp; 1&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when&nbsp; @m&nbsp; between&nbsp; 4&nbsp; and&nbsp; 6&nbsp; then&nbsp; 4&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when&nbsp; @m&nbsp; between&nbsp; 7&nbsp; and&nbsp; 9&nbsp; then&nbsp; 7&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp; 10&nbsp; end&nbsp;&nbsp; <br />select&nbsp; @time=datename(year,getdate())+'-'+convert(varchar(10),@m)+'-01'&nbsp;&nbsp; <br />select&nbsp; datediff(day,@time,dateadd(mm,3,@time)) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />/////////////////////////////////////////<br />KeyLife富翁笔记&nbsp; <br />作者: goddy<br />标题: sql <br />关键字: <br />分类: 个人专区 <br />密级: 公开 <br />(评分: , 回复: 0, 阅读: 137) ?? <br />1. 行列转换<br />假设有张学生成绩表(CJ)如下<br />Name&nbsp;&nbsp;&nbsp; Subject&nbsp;&nbsp;&nbsp;&nbsp; Result<br />张三&nbsp;&nbsp;&nbsp; 语文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80<br />张三&nbsp;&nbsp;&nbsp; 数学&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90<br />张三&nbsp;&nbsp;&nbsp; 物理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 85<br />李四&nbsp;&nbsp;&nbsp; 语文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 85<br />李四&nbsp;&nbsp;&nbsp; 数学&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 92<br />李四&nbsp;&nbsp;&nbsp; 物理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 82</p>
<p>想变成&nbsp;&nbsp;&nbsp; <br />姓名&nbsp;&nbsp; 语文&nbsp;&nbsp; 数学&nbsp;&nbsp; 物理<br />张三&nbsp;&nbsp; 80&nbsp;&nbsp;&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp; 85<br />李四&nbsp;&nbsp; 85&nbsp;&nbsp;&nbsp;&nbsp; 92&nbsp;&nbsp;&nbsp;&nbsp; 82</p>
<p>解决如下<br />declare @sql varchar(4000)<br />set @sql = 'select Name'<br />select @sql = @sql + ',sum(case Subject when '''+Subject+''' then Result end) ['+Subject+']'<br />&nbsp;from (select distinct Subject from CJ) as a<br />select @sql = @sql+' from test group by name'<br />exec(@sql)</p>
<p>另外在Access中还提供了TransForm来实现行列转换<br />TRANSFORM count(Result) AS number <br />SELECT 姓名 <br />FROM 学生成绩表 <br />GROUP BY 姓名 <br />PIVOT Subject;</p>
<p>TransForm 用法如下:<br />=========================================================<br />TRANSFORM aggfunction <br />selectstatement <br />PIVOT pivotfield [IN (value1[, value2[, ...]])] </p>
<p>TRANSFORM 语句可分为以下几个部分： </p>
<p>部分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 描述 <br />aggfunction 在选定数据上运作的 SQL 合计函数。 <br />selectstatement&nbsp; SELECT 语句。 <br />pivotfield 在查询的结果集中创建列标题时用的字段或表达式。 <br />value1, value2 用来创建列标题的固定值。 </p>
<p>说明 <br />使用交叉表查询来摘要数据时，从指定的字段或表达式中选定值作为列标题， <br />这样，可以用比选定查询更紧凑的格式来观察数据。 <br />TRANSFORM 是可选的，但在使用它时，要作为&nbsp; SQL 字符串中的第一个语句。 <br />它出现在 SELECT 语句（指定作为行标题的字段的）之前，还出现在 GROUP BY 子句 <br />（指定行分组的）之前。可以有选择地包含其它子句，例如 WHERE 子句，它指定附 <br />加的选择或排序条件。也可以将子查询当作谓词，特别是在叉表查询的 WHERE 子句中。 </p>
<p>pivotfield 返回的值被用作查询结果集中的列标题。 <br />例如，在交叉表查询中，将根据销售图表按销售月份创建 12 个列。 <br />可以限制 pivotfield 用列在可选的 IN 子句中的固定值（value1, value2）来创建标题。 <br />也可以用没有数据存在的固定值来创建附加的列。 <br />==================================================================================</p>
<p>2. 列行转换<br />暂时保留</p>
<p>3. 行列转换--加合并<br />有表A,<br />&nbsp;id pid<br />&nbsp;1&nbsp;&nbsp; 1<br />&nbsp;1&nbsp;&nbsp; 2<br />&nbsp;1&nbsp;&nbsp; 3<br />&nbsp;2&nbsp;&nbsp; 1<br />&nbsp;2&nbsp;&nbsp; 2<br />&nbsp;3&nbsp;&nbsp; 1<br />如何化成表B:<br />&nbsp;id pid<br />&nbsp; 1&nbsp; 1,2,3<br />&nbsp; 2&nbsp; 1,2<br />&nbsp; 3&nbsp; 1</p>
<p>创建一个合并的函数<br />create function fmerg(@id int)<br />returns varchar(8000)<br />as<br />begin<br />declare @str varchar(8000)<br />set @str=''<br />select @str=@str+','+cast(pid as varchar) from 表A where <a href="mailto:id=@id">id=@id</a><br />set @str=right(@str,len(@str)-1)<br />return(@str)<br />End<br />go</p>
<p>--调用自定义函数得到结果<br />select distinct id,dbo.fmerg(id) from 表A</p>
<p>4. 如何取得一个数据表的所有列名<br />方法如下：先从SYSTEMOBJECT系统表中取得数据表的SYSTEMID,然后再SYSCOLUMN表中取得该数据表的所有列名。<br />SQL语句如下：<br />declare @objid int,@objname char(40)<br />set @objname = 'tablename'<br />select @objid = id from sysobjects where id = object_id(@objname)<br />select 'Column_name' = name from syscolumns where id = @objid order by colid</p>
<p>是不是太简单了？ 呵呵 不过经常用阿.</p>
<p>5. 通过SQL语句来更改用户的密码</p>
<p>修改别人的,需要sysadmin&nbsp; role&nbsp;&nbsp;&nbsp; <br />EXEC&nbsp; sp_password&nbsp; NULL,&nbsp; 'newpassword',&nbsp; 'User'</p>
<p>如果帐号为SA执行EXEC&nbsp; sp_password&nbsp; NULL,&nbsp; 'newpassword',&nbsp; sa&nbsp; </p>
<p>6.怎么判断出一个表的哪些字段不允许为空？</p>
<p>select&nbsp; COLUMN_NAME&nbsp; from&nbsp; INFORMATION_SCHEMA.COLUMNS&nbsp; where&nbsp; IS_NULLABLE='NO'&nbsp; and&nbsp; TABLE_NAME=tablename&nbsp; </p>
<p>7.如何在数据库里找到含有相同字段的表？<br />a. 查已知列名的情况<br />SELECT&nbsp; b.name&nbsp; as&nbsp; TableName,a.name&nbsp; as&nbsp; columnname&nbsp; <br />From&nbsp; syscolumns&nbsp;&nbsp;&nbsp; a&nbsp; INNER&nbsp; JOIN&nbsp;&nbsp;&nbsp; sysobjects&nbsp; b&nbsp;&nbsp;&nbsp; <br />ON&nbsp; a.id=b.id&nbsp;&nbsp;&nbsp; <br />AND&nbsp; b.type='U'&nbsp;&nbsp;&nbsp; <br />AND&nbsp; a.name='你的字段名字'&nbsp; <br />b. 未知列名查所有在不同表出现过的列名<br />Select&nbsp; o.name&nbsp; As&nbsp; tablename,s1.name&nbsp; As&nbsp; columnname&nbsp; <br />From&nbsp; syscolumns&nbsp; s1,&nbsp; sysobjects&nbsp; o&nbsp; <br />Where&nbsp; s1.id&nbsp; =&nbsp; o.id&nbsp; <br />&nbsp;&nbsp; And&nbsp; o.type&nbsp; =&nbsp; 'U'&nbsp; <br />&nbsp;&nbsp; And&nbsp; Exists&nbsp; (&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select&nbsp; 1&nbsp; From&nbsp; syscolumns&nbsp; s2&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where&nbsp; s1.name&nbsp; =&nbsp; s2.name&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; And&nbsp; s1.id&nbsp; &lt;&gt;&nbsp; s2.id&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br />8.查询第xxx行数据</p>
<p>假设id是主键：&nbsp; <br />select&nbsp; *&nbsp; <br />from&nbsp; (select&nbsp; top&nbsp; xxx&nbsp; *&nbsp; from&nbsp; yourtable)&nbsp; aa&nbsp; <br />where&nbsp; not&nbsp; exists(select&nbsp; 1&nbsp; from&nbsp; (select&nbsp; top&nbsp; xxx-1&nbsp; *&nbsp; from&nbsp; yourtable)&nbsp; bb&nbsp; where&nbsp; aa.id=bb.id)<br />如果使用游标也是可以的&nbsp; <br />fetch&nbsp; absolute&nbsp; [number]&nbsp; from&nbsp; [cursor_name]&nbsp; <br />行数为绝对行数</p>
<p>9.SQL Server日期计算<br />a. 一个月的第一天<br />SELECT&nbsp; DATEADD(mm,&nbsp; DATEDIFF(mm,0,getdate()),&nbsp; 0)&nbsp; <br />b. 本周的星期一<br />SELECT&nbsp; DATEADD(wk,&nbsp; DATEDIFF(wk,0,getdate()),&nbsp; 0) <br />c. 一年的第一天<br />SELECT&nbsp; DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate()),&nbsp; 0)&nbsp; <br />d. 季度的第一天<br />SELECT&nbsp; DATEADD(qq,&nbsp; DATEDIFF(qq,0,getdate()),&nbsp; 0)&nbsp; <br />e. 上个月的最后一天 <br />SELECT&nbsp; dateadd(ms,-3,DATEADD(mm,&nbsp; DATEDIFF(mm,0,getdate()),&nbsp; 0))&nbsp; <br />f. 去年的最后一天<br />SELECT&nbsp; dateadd(ms,-3,DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate()),&nbsp; 0)) <br />g. 本月的最后一天<br />SELECT&nbsp; dateadd(ms,-3,DATEADD(mm,&nbsp; DATEDIFF(m,0,getdate())+1,&nbsp; 0))&nbsp; <br />h. 本月的第一个星期一<br />select&nbsp; DATEADD(wk,&nbsp; DATEDIFF(wk,0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dateadd(dd,6-datepart(day,getdate()),getdate())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),&nbsp; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />i. 本年的最后一天<br />SELECT&nbsp; dateadd(ms,-3,DATEADD(yy,&nbsp; DATEDIFF(yy,0,getdate())+1,&nbsp; 0))。</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////<br />保存 评价 游戏规则 免费注册&nbsp; 资料下载 关于本站&nbsp; <br />问题分类 编程问题 非技术题 富翁列表 我的信息 提出问题 在线富翁 富翁日历 笔记列表 我的笔记 写作笔记 全文检索 《专家门诊》&nbsp; </p>
<p>富翁名称: guolei0451 <br />专 家 分: 0 <br />可用积分: 94 </p>
<p>退出论坛<br />&nbsp;</p>
<p>--------------------------------------------------------------------------------</p>
<p>友站直通车 ！</p>
<p><br />管理我的信息<br />富翁之家模板<br />聊天室记事本<br />我的待答问题<br />我的已答问题<br />我收藏的问题<br />我参与的问题<br />查关键词&nbsp; <br />检索LID&nbsp; </p>
<p>--------------------------------------------------------------------------------</p>
<p><br />--------------------------------------------------------------------------------</p>
<p>大富翁论坛版权所有<br />&nbsp;KeyLife富翁笔记&nbsp; <br />作者: HrSoft<br />标题: SQL语句特殊技巧吧 <br />关键字: <br />分类: 个人专区 <br />密级: 公开 <br />(评分: , 回复: 0, 阅读: 450) ?? <br />上次写了个ACCESS技巧集,反映良好,这次来个SQL语句特殊技巧吧</p>
<p>1.把某个字段重新生气序列(从1到n):<br />DECLARE @i int<br />Set @i = 0<br />Update Table1 Set @i = @i + 1,Field1 = @i</p>
<p>2.按成绩排名次<br />Update 成绩表<br />Set a.名次 = (<br />&nbsp; Select Count(*) + 1<br />&nbsp; From 成绩表 b<br />&nbsp; Where a.总成绩 &lt; b.总成绩<br />)<br />From 成绩表 a</p>
<p>3.查询外部数据库<br />Select a.*<br />From OpenRowSet('Microsoft.Jet.OLEDB.4.0','c:\test.mdb';'admin';'',Table1) a</p>
<p>4.查询Excel文件<br />Select * <br />From OpenDataSource('Microsoft.Jet.OLEDB.4.0','Data Source=&quot;c:\test.xls&quot;;User ID=Admin;Password=;Extended properties=Excel 8.0')...Sheet1$</p>
<p>5.在查询中指定排序规则<br />Select * From Table1 Order By Field1 COLLATE Chinese_PRC_BIN<br />为什么要指定排序规则呢?参见:<br /><a href="http://www.delphibbs.com/delphibbs/dispq.asp?lid=1633985">http://www.delphibbs.com/delphibbs/dispq.asp?lid=1633985</a><br />例,检查数据库中的Pub_Users表中是否存在指定的用户:<br />Select Count(*) From Pub_Users Where [UserName]='admin' And [PassWord]='aaa' COLLATE Chinese_PRC_BIN<br />默认比较是不区分大小写的,如果不加COLLATE Chinese_PRC_BIN,那么密码aaa与AAA是等效的,这当然与实际不符.注意的是,每个条件都要指定排序规则,上例中用户名就不区分大小写.</p>
<p><br />6.Order By的一个小技巧<br />Order By可以指定列序而不用指定列名,在下面的例子里说明它的用处(注意,第三列未指定别名)<br />Select a.ID,a.Name,(Select Count(*) From TableB b Where a.ID=b.PID) From TableA a Order By 3</p>
<p>待续... </p>
<p>&nbsp;</p>
<p>2003-10-6 13:53:00&nbsp;&nbsp;&nbsp; <br />&nbsp;发表评语&amp;raquo;&amp;raquo;&amp;raquo;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;2003-12-6 19:36:00&nbsp;&nbsp;&nbsp; 7.字符串之Sum???例如，有个表<br />&nbsp; ID&nbsp;&nbsp; NAME<br />------------------<br />&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; T<br />&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; H<br />&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; A <br />&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; N<br />&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; K<br />要得到<br />THANK</p>
<p>declare @s varchar(100);<br />set @s='';<br />select @s=@s+[Name] from 表 order by id;<br />select @s;<br /><a href="http://www.delphibbs.com/delphibbs/dispq.asp?lid=2290831">http://www.delphibbs.com/delphibbs/dispq.asp?lid=2290831</a> </p>
<p>&nbsp;<br />&nbsp;2005-10-10 12:56:05&nbsp;&nbsp;&nbsp; 再来一个排名的,没有排名字段查询排名create table t1<br />(khid varchar(10), xsje money)</p>
<p>insert into t1 values ('001',100)<br />insert into t1 values ('002',105)<br />insert into t1 values ('003',220)<br />insert into t1 values ('004',89)<br />insert into t1 values ('001',150)<br />insert into t1 values ('002',50)<br />insert into t1 values ('003',38)</p>
<p>select (<br />&nbsp;&nbsp;&nbsp; select count(*) + 1 from (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select khid,sum(xsje) as xsje from t1 group by khid<br />&nbsp;&nbsp;&nbsp; ) b where a.xsje &lt; b.xsje<br />) mc,* from (<br />&nbsp;&nbsp;&nbsp; select khid,sum(xsje) as xsje from t1 group by khid<br />) a order by mc</p>
<p>优点:允许并列排名,纯查询<br />缺点:要做两次sum扫描源表<br />问题见:http://www.delphibbs.com/delphibbs/dispq.asp?lid=3231593</p>
<p>修改一下以适应于ACCESS<br />select (<br />&nbsp;&nbsp;&nbsp; select count(*) + 1 from (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select khid,sum(xsje) as xsje_sum from t1 group by khid<br />&nbsp;&nbsp;&nbsp; ) as b where a.xsje_sum &lt; b.xsje_sum<br />) as mc,* from (<br />&nbsp;&nbsp;&nbsp; select khid,sum(xsje) as xsje_sum from t1 group by khid<br />) as a order by xsje_sum desc&nbsp;&nbsp; <br />/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br />保存 评价 游戏规则 免费注册&nbsp; 资料下载 关于本站&nbsp; <br />问题分类 编程问题 非技术题 富翁列表 我的信息 提出问题 在线富翁 富翁日历 笔记列表 我的笔记 写作笔记 全文检索 《专家门诊》&nbsp; </p>
<p>富翁名称: guolei0451 <br />专 家 分: 0 <br />可用积分: 94 </p>
<p>退出论坛<br />&nbsp;</p>
<p>--------------------------------------------------------------------------------</p>
<p>友站直通车 ！</p>
<p><br />管理我的信息<br />富翁之家模板<br />聊天室记事本<br />我的待答问题<br />我的已答问题<br />我收藏的问题<br />我参与的问题<br />查关键词&nbsp; <br />检索LID&nbsp; </p>
<p>--------------------------------------------------------------------------------</p>
<p><br />--------------------------------------------------------------------------------</p>
<p>大富翁论坛版权所有<br />&nbsp;KeyLife富翁笔记&nbsp; <br />作者: cg.410<br />标题: SQL基础知识大全 <br />关键字: <br />分类: 个人专区 <br />密级: 公开 <br />(评分: , 回复: 0, 阅读: 2376) ?? <br />SQL基础知识大全 <br />&nbsp;&nbsp; SQL语言由命令、子句、运算和集合函数等构成。在SQL中，数据定义语言DDL（用来建立及定义数据表、字段以及索引等数据库结构）包含的命令有CREATE、DROP、ALTER；数据操纵语言DML（用来提供数据的查询、排序以及筛选数据等功能）包含的命令有SELECT、INSERT、UPDATE、DELETE。</p>
<p>一、SQL语句</p>
<p>（1）Select 查询语句<br />语法：SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [AS 列名]<br />[,&lt;目标列表达式&gt; [AS 列名] ...] FROM &lt;表名&gt; [，&lt;表名&gt;&hellip;]<br />[WHERE &lt;条件表达式&gt; [AND|OR &lt;条件表达式&gt;...]<br />[GROUP BY 列名 [HAVING &lt;条件表达式&gt;]]<br />[ORDER BY 列名 [ASC | DESC]] <br />解释：[ALL|DISTINCT]&nbsp;&nbsp; ALL：全部； DISTINCT：不包括重复行<br />&lt;目标列表达式&gt; 对字段可使用AVG、COUNT、SUM、MIN、MAX、运算符等<br />&lt;条件表达式&gt; <br />查询条件 谓词<br />比较 =、&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,<br />确定范围 BETWEEN AND、NOT BETWEEN AND<br />确定集合 IN、NOT IN<br />字符匹配 LIKE（&ldquo;%&rdquo;匹配任何长度，&ldquo;_&rdquo;匹配一个字符）、NOT LIKE<br />空值 IS NULL、IS NOT NULL<br />子查询 ANY、ALL、EXISTS<br />集合查询 UNION（并）、INTERSECT（交）、MINUS（差）<br />多重条件 AND、OR、NOT<br />&lt;GROUP BY 列名&gt; 对查询结果分组<br />[HAVING &lt;条件表达式&gt;] 分组筛选条件<br />[ORDER BY 列名 [ASC | DESC]] 对查询结果排序；ASC：升序 DESC：降序<br />例1： select student.sno as 学号, student.name as 姓名, course as 课程名, score as 成绩 from score,student where student.sid=score.sid and score.sid=:sid<br />例2：select student.sno as 学号, student.name as 姓名,AVG(score) as 平均分 from score,student where student.sid=score.sid and student.class=:class and (term=5 or term=6) group by student.sno, student.name having count(*)&gt;0 order by 平均分 DESC<br />例3：select * from score where sid like '9634'<br />例4：select * from student where class in (select class from student where name='陈小小')</p>
<p>（2）INSERT插入语句<br />语法：INSERT INTO &lt;表名&gt; [（&lt;字段名1&gt; [,&lt;字段名2&gt;, ...])] VALUES (&lt;常量1&gt; [,&lt;常量2&gt;, ...]) <br />语法：INSERT INTO &lt;表名&gt; [（&lt;字段名1&gt; [,&lt;字段名2&gt;, ...])] 子查询 <br />例子：INSERT INTO 借书表（rid,bookidx,bdate）VALUES (edit1.text,edit2.text,date)<br />例子：INSERT INTO score1(sno,name) SELECT sno,name FROM student WHERE class=&rsquo;9634&rsquo;</p>
<p>（3）UPDATE-SQL<br />语法：UPDATE 〈表名〉<br />SET 列名1 = 常量表达式1[,列名2 = 常量表达式2 ...]<br />WHERE &lt;条件表达式&gt; [AND|OR &lt;条件表达式&gt;...]<br />例子：update score set credithour=4 where course='数据库'</p>
<p>（4）DELETE-SQL<br />语法：DELETE FROM〈表名〉[WHERE &lt;条件表达式&gt; [AND|OR &lt;条件表达式&gt;...]]<br />例子：Delete from student where sid='003101'</p>
<p>（5）CREATE TABLE<br />CREATE TABLE | DBF TableName1 [NAME LongTableName] [FREE]<br />(FieldName1 FieldType [(nFieldWidth [, nPrecision])]<br />&nbsp; [NULL | NOT NULL] <br />&nbsp; [CHECK lExpression1 [ERROR cMessageText1]]<br />&nbsp; [DEFAULT eExpression1]<br />&nbsp; [PRIMARY KEY | UNIQUE]<br />&nbsp; [REFERENCES TableName2 [TAG TagName1]]<br />&nbsp; [NOCPTRANS]<br />[, FieldName2 ...]<br />&nbsp; [, PRIMARY KEY eExpression2 TAG TagName2<br />|, UNIQUE eExpression3 TAG TagName3]<br />&nbsp; [, FOREIGN KEY eExpression4 TAG TagName4 [NODUP]<br />&nbsp; REFERENCES TableName3 [TAG TagName5]]<br />&nbsp; [, CHECK lExpression2 [ERROR cMessageText2]])<br />| FROM ARRAY ArrayName</p>
<p>（6）ALTER TABLE<br />ALTER TABLE TableName1<br />ADD | ALTER [COLUMN] FieldName1<br />&nbsp; FieldType [(nFieldWidth [, nPrecision])]<br />&nbsp; [NULL | NOT NULL]<br />&nbsp; [CHECK lExpression1 [ERROR cMessageText1]]<br />&nbsp; [DEFAULT eExpression1]<br />&nbsp; [PRIMARY KEY | UNIQUE]<br />&nbsp; [REFERENCES TableName2 [TAG TagName1]]<br />&nbsp; [NOCPTRANS]</p>
<p>（7）DROP TABLE<br />DROP TABLE [路径名.]表名</p>
<p>（8）CREATE INDEX<br />CREATE INDEX index-name ON table-name（column[，column&hellip;]）<br />例：CREATE INDEX uspa ON 口令表(user,password)</p>
<p>（9）DROP INDEX<br />DROP INDEX table-name.index-name|PRIMARY<br />例：DROP INDEX 口令表.uspa</p>
<p>二、在程序中使用静态SQL语句<br />&nbsp; 在程序设计阶段，将SQL命令文本作为TQuery组件的SQL属性值设置。</p>
<p>三、在程序中使用动态SQL语句<br />&nbsp; 动态SQL语句是指在SQL语句中包含有参数变量的SQL语句（如：select * from student where class=:class），在程序中可以为参数赋值。给参数赋值的方法有：</p>
<p>&nbsp; 1、利用参数编辑器为参数赋值<br />&nbsp; 选中TQuery组件，在对象监视器OI中点取Params项，在弹出的参数编辑窗口中设置参数的值。<br />例：SELECT bookidx AS 书号,藏书表.bookname AS 书名, bdate AS 借书日期 FROM 借书表,藏书表 where 借书表.bookidx=藏书表.bookidx and rid=:rid</p>
<p>&nbsp; 2、在程序运行中通过程序为参数赋值<br />（1）根据参数在SQL语句中出现的顺序，使用TQuery的Params属性为参数赋值；</p>
<p>例：在借书表中插入一条记录<br />with Query1 do<br />begin<br />&nbsp; SQL.clear;<br />&nbsp; SQL.add('Insert Into 借书表（bookidx,rid,rdate）');<br />&nbsp; SQl.add('Values(:bookidx,:rid,:rdate)');<br />&nbsp; Params[0].AsString := bookidxEdit.Text;<br />&nbsp; Params[1].AsString := ridEdit.Text;<br />&nbsp; Params[2] .AsDate:=date;<br />&nbsp; ExecSQL;<br />End;</p>
<p>（2）根据SQL语句中的参数名字，调用ParamByName方法为参数赋值；<br />ParamByName('bookidx').AsString := bookidxEdit.Text;<br />ParamByName('rid').AsString := ridEdit.Text;<br />ParamByName('rdate') .AsDate:=date;<br />ExecSQL;<br />有：AsString 、AsSmallInt 、AsInteger 、AsWord 、AsBoolean 、AsFloat 、AsCurrency 、AsBCD 、AsDate 、AsTime 、AsDateTime转换函数</p>
<p>3、使用数据源为参数赋值<br />&nbsp; 把TQuery的DataSource属性设置为另一个数据源（T DataSource名字），Delphi会把未赋值的参数与指定的数据源中的各字段相比较，并将匹配的字段的值赋给未赋值的参数，可实现主表&mdash;明细表应用。</p>
<p>四、对TQuery返回的数据集进行修改<br />&nbsp; 一般情况下，TQuery返回的数据集是只读的，不能修改；<br />&nbsp; 对不包含集操作（如：SUM、COUNT）的单表SELECT查询，设置TQuery的RequsetLive属性为True，则可修改TQuery返回的数据集。</p>
<p>var<br />I: Integer;<br />ListItem: string;<br />begin<br />for I := 0 to Query1.ParamCount - 1 do<br />begin<br />&nbsp; ListItem := ListBox1.Items[I];<br />&nbsp; case Query1.Params[I].DataType of<br />&nbsp;&nbsp;&nbsp; ftString:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsString := ListItem;<br />&nbsp;&nbsp;&nbsp; ftSmallInt:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsSmallInt := StrToIntDef(ListItem, 0);<br />&nbsp;&nbsp;&nbsp; ftInteger:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsInteger := StrToIntDef(ListItem, 0);<br />&nbsp;&nbsp;&nbsp; ftWord:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsWord := StrToIntDef(ListItem, 0);<br />&nbsp;&nbsp;&nbsp; ftBoolean:<br />&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ListItem = 'True' then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query1.Params[I].AsBoolean := True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query1.Params[I].AsBoolean := False;<br />&nbsp;&nbsp;&nbsp; end;<br />&nbsp;&nbsp;&nbsp; ftFloat:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsFloat := StrToFloat(ListItem);<br />&nbsp;&nbsp;&nbsp; ftCurrency:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsCurrency := StrToFloat(ListItem);<br />&nbsp;&nbsp;&nbsp; ftBCD:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsBCD := StrToCurr(ListItem);<br />&nbsp;&nbsp;&nbsp; ftDate:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsDate := StrToDate(ListItem);<br />&nbsp;&nbsp;&nbsp; ftTime:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsTime := StrToTime(ListItem);<br />&nbsp;&nbsp;&nbsp; ftDateTime:<br />&nbsp;&nbsp;&nbsp; Query1.Params[I].AsDateTime := StrToDateTime(ListItem);<br />&nbsp; end;<br />end;<br />end; </p>
<p><br />2003-11-25 9:59:00&nbsp;&nbsp; <br />查看评语???&nbsp;&nbsp; </p>
<p>2003-11-25 10:06:20&nbsp;&nbsp; 运行期间对数据库表的<br />一、数据集表的打开与关闭<br />打开：设置数据集组件的Active属性为True或调用数据集组件的Open方法<br />关闭：设置数据集组件的Active属性为False或调用数据集组件的Close方法</p>
<p>二、创建数据库应用程序<br />?利用向导创建：使用Database菜单/Form Wizard选项；<br />?创建主从表：设置从表的MasterSource、MasterField属性；<br />?创建查询表：使用TQuery组件；</p>
<p>三、数据库表记录的定位<br />?使用TDBNavigator组件；<br />?调用数据集组件的First、Next、Prior、Last方法；<br />?数据集组件的EOF属性（或BOF属性）用来判断记录指针是否指向第一条记录（或最后一条记录）；<br />?使用数据集的书签BookMark（GetBookMark：获得当前记录的BookMark记号；GotoBookMark：从当前记录直接转到指定BookMark的那条记录；FreeBookMark：释放某个BookMark）<br />?使用GotoKey、FindKey方法查找记录进行定位；</p>
<p>四、数据库表字段对象的使用</p>
<p>（1）创建永久的字段对象<br />&nbsp; 双击或单击再右击TTable(TQuery)对象打开字段编辑器，使用其弹出菜单增加字段对象、删除字段对象、定义新的字段对象（字段编辑器的弹出菜单的New Fields选项，可创建计算字段）；</p>
<p>（2）字段对象的属性、方法、事件<br />&nbsp; 字段对象名：如Table1Name、Query1Sid<br />&nbsp; 属性:Alignment（对齐方式）、Calculated（是否是从其它字段值计算得到）、DisplayLabel（显示的标题）、DisplayWidth（显示的宽度）、DisplayFormat（显示的格式）、EditMask（输入的限制）、FieldName（字段名）、ReadOnly（是否只读）、Visible（是否显示）<br />&nbsp; 事件：OnChange（字段值发生变化时触发）、OnGetText（当字段对象获得字段值时触发）、OnSetText（当字段对象被设置字段值时触发）、OnValiData（当修改、插入、进行有效性检验时触发）</p>
<p>（3）字段对象的类型转换<br />&nbsp; 有：AsString 、AsSmallInt 、AsInteger 、AsWord 、AsBoolean 、AsFloat 、AsCurrency 、AsBCD 、AsDate 、AsTime 、AsDateTime转换函数<br />如：Edit1.Text:=Table1Name.Value ;<br />Table1Bdate.AsString:=DateToStr(DATE) ;</p>
<p>（4）对字段对象的访问<br />&nbsp; 动态字段对象的访问：Table1.Fields[0]. DisplayLabel:= '学生编号'<br />Table1.FieldByName('Sid'). DisplayLabel:= '学生编号' Table1.Fields[0].Assignment:=taCenter<br />Edit1.Text:= Table1.FieldByName('Sid').AsString<br />&nbsp; 永久字段对象的访问：Query1Sid.DisplayLabel:= '学生编号' <br />Query1Sid.DisplayWidth:= 12</p>
<p>五、对数据库表数据的操作方法</p>
<p>（1）访问表中某一字段的数据的方法：<br />?Table1.FieldByName（'bookidx'）.AsString<br />?Table1.Field[0].AsInteger<br />?Table1.Fieldvalues['bookidx']</p>
<p>（2）数据库表的一些属性：<br />?当前记录号：Table1.Recno<br />?记录总数：Table1.RecordCount<br />?得到表的字段名：Table1.GetFieldNames（ListBox1。Items）</p>
<p>（3）数据维护的方法：<br />?Edit方法：把数据集设置为编辑状态；<br />?Append方法：把数据集设置为插入状态（最后）；<br />?Insert方法：把数据集设置为插入状态（当前记录后）；<br />?Post方法：把修改的记录写回数据集；<br />?Cancel方法：取消当前的操作；<br />?Delete方法：删除表中当前记录；<br />?AppendRecord方法：<br />?InsertRecord方法：table1.InsertRecord（['963409', NIL, NIL，'考试']）；<br />?SetRecords方法：<br />?Abort方法：取消各种方法的调用；</p>
<p>（4）输入数据的合法性验证<br />&nbsp; 对数据库表建立合法性验证机制（如在DBD设置表的Validity Check、Table Lookup、Referential Integrity等属性）；<br />? 在字段编辑表Fields Editor（双击Ttable对象），选择字段，编写其OnValidate事件，要求非空可设置其Required属性为True；<br />? 在程序中防止不合法输入（如：使用TDBcombobox对象，TDBlookupcombobox对象）；</p>
<p>六、数据检索<br />（1）利用索引排序<br />&nbsp; 如：TABLE1.IndexName:='uspa' 或TABLE1.IndexFieldNames:='user_id'<br />（2）使用GotoKey方法查找数据库中的记录<br />? 要求查找字段建立了索引，非主索引要设置Ttable对象的IndexName属性。<br />? 调用SetKey方法，把要查找的Ttable对象置成查找模块；<br />? 把查找值送进被查找的Field的查找缓冲区；<br />? 调用Ttable对象的GotoKey方法，测试该方法的返回值判断查找是否成功；<br />（3）使用FindKey方法查找数据库中的记录<br />&nbsp; 把查找值作为参数传递给FindKey函数，允许有多个查找值，要求把要查找的多个字段的索引名赋给Ttable对象的IndexName属性；<br />（4）不精确查找<br />&nbsp; GotoNearest方法<br />&nbsp; FindNearest方法<br />（5）使用Locate方法查找数据库中的记录(不用建索引)<br />&nbsp; table1.locate(&lsquo;字段名1；字段名2&rsquo;，VarArroyof（[&lsquo;值1&rsquo;，&lsquo;值2&rsquo;]），[LoCaseInsensitive，LoPartialKey])<br />&nbsp; LoCaseInsensitive：忽略大小写；IoPartialKey：不精确查找<br />（6）设定查找范围的方法<br />&nbsp; SetRangeStart、SetRangeEnd、EditRangeStart、EditRangeEnd、SetRange（[Start Values]，[End Value]）、ApplyRange、CancelRange<br />（7）用TQuery组件的动态SQL语句进行查找</p>
<p>七、修改数据库中的记录<br />&nbsp; 在程序中对数据库记录进行操作可按下列的步骤进行：<br />（1）移动数据指针到要修改的记录；<br />（2）调用Edit方法将Ttable组件设置成编辑状态；<br />（3）修改字段值；（Table1.Fieldvalues['字段名']:=值、Table1.Field[0].AsString:=值）<br />（4）可用Nil对字段赋空值；<br />（5）调用Post方法将修改后的记录写入数据库；</p>
<p>八、插入和删除记录<br />&nbsp; 删除：移动指针到相应记录处，调用Delete方法；<br />&nbsp; 插入：调用Insert、InsertRecord方法（当前记录处插入）或Append、InsertRecord方法（表的末尾插入）； </p>
<p><br />2003-11-25 10:11:12&nbsp;&nbsp; 动态的添加PARADOX表的方法【王寒松】下面给出的函数 AddMasterPassword 完成添加PARADOX表主口令的工作<br />AddMasterPassword(Table1, 'MyNewPassword') <br />procedure AddMasterPassword(Table: TTable; pswd: string);<br />const<br />&nbsp; RESTRUCTURE_TRUE = WordBool(1);<br />var<br />&nbsp; TblDesc: CRTblDesc;<br />&nbsp; hDb: hDBIDb;<br />begin<br />&nbsp; {表打开？表是独占吗？}<br />&nbsp; if (Table.Active = False) or (Table.Exclusive = False) then<br />&nbsp;&nbsp;&nbsp; raise EDatabaseError.Create('数据表必须在独占方式才可以添加口令');<br />&nbsp; {初始化表描述区 }<br />&nbsp; FillChar(TblDesc, SizeOf(CRTblDesc), 0);<br />&nbsp; with TblDesc do<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; { 把表名放到描述区 }<br />&nbsp;&nbsp;&nbsp; StrPCopy(szTblName, Table.TableName);<br />&nbsp;&nbsp;&nbsp; { 把表类型放到描述区 }<br />&nbsp;&nbsp;&nbsp; StrCopy(szTblType, szPARADOX);<br />&nbsp;&nbsp;&nbsp; StrPCopy(szPassword, pswd);<br />&nbsp;&nbsp;&nbsp; { 设置BPROTECTED为TRUE }<br />&nbsp;&nbsp;&nbsp; bProtected := RESTRUCTURE_TRUE;<br />&nbsp; end;<br />&nbsp; { 从当前的HANDLE里得到DATABASE的HANDLE }<br />&nbsp; Check(DbiGetObjFromObj(hDBIObj(Table.Handle), objDATABASE, hDBIObj(hDb)));<br />&nbsp; { 关闭表 }<br />&nbsp; Table.Close;<br />&nbsp; { 添加主口令到PARADOX表里}<br />&nbsp; Check(DbiDoRestructure(hDb, 1, @TblDesc, nil, nil, nil, FALSE));<br />&nbsp; {添加一个新口令到SESSION}<br />&nbsp; Session.AddPassword(pswd);<br />&nbsp; {重新打开表 }<br />&nbsp; Table.Open;<br />end;<br />添加副口令的办法与此类似 </p>
<p><br />2003-11-25 11:21:29&nbsp;&nbsp; 如何选择一个好的数据库【三大数据库比较】 <br />【开放性】</p>
<p>SQL Server<br />&nbsp; 只能在windows 上运行，没有丝毫的开放性，操作系统的系统的稳定对数据库是十分重要的。Windows9X系列产品是偏重于桌面应用，NT server只适合中小型企业。而且windows平台的可靠性，安全性和伸缩性是非常有限的。它不象unix那样久经考验，尤其是在处理大数据量的关键业务时.</p>
<p>Oracle<br />&nbsp; 能在所有主流平台上运行（包括 windows）。完全支持所有的工业标准。采用完全开放策略。可以使客户选择最适合的解决方案。对开发商全力支持。</p>
<p>DB2<br />&nbsp; 能在所有主流平台上运行（包括windows）。最适于海量数据。DB2在企业级的应用最为广泛,在全球的500家最大的企业中,几乎85%以上用DB2数据库服务器,而国内到97年约占5%.</p>
<p><br />【可伸缩性,并行性】</p>
<p>SQL server<br />&nbsp; 并行实施和共存模型并不成熟。很难处理日益增多的用户数和数据卷。伸缩性有限。</p>
<p>Oracle<br />&nbsp; 平行服务器通过使一组结点共享同一簇中的工作来扩展windownt的能力,提供高可用性和高伸缩性的簇的解决方案。如果windowsNT不能满足需要, 用户可以把数据库移到UNIX中。</p>
<p>DB2&nbsp;&nbsp; <br />&nbsp; DB2具有很好的并行性。DB2把数据库管理扩充到了并行的、多节点的环境.数据库分区是数据库的一部分，包含自己的数据、索引、配置文件、和事务日志。数据库分区有时被称为节点或数据库节点</p>
<p><br />【安全性】</p>
<p>SQL server<br />&nbsp; 没有获得任何安全证书。</p>
<p>Oracle Server<br />&nbsp; 获得最高认证级别的ISO标准认证。</p>
<p>DB2<br />&nbsp; 获得最高认证级别的ISO标准认证。</p>
<p><br />【性能】</p>
<p>SQL Server<br />&nbsp; 多用户时性能不佳</p>
<p>Oracle<br />&nbsp; 性能最高， 保持windowsNT下的TPC-D和TPC-C的世界记录。</p>
<p>DB2<br />&nbsp; 适用于数据仓库和在线事物处理,性能较高。</p>
<p><br />【客户端支持及应用模式】</p>
<p>SQL Server<br />&nbsp; C/S结构，只支持windows客户，可以用ADO,DAO,OLEDB,ODBC连接.</p>
<p>Oracle<br />&nbsp; 多层次网络计算，支持多种工业标准，可以用ODBC,JDBC,OCI等网络客户连接</p>
<p>DB2<br />&nbsp; 跨平台，多层结构，支持ODBC,JDBC等客户</p>
<p><br />【操作简便】</p>
<p>SQL Server<br />&nbsp; 操作简单,但只有图形界面.</p>
<p>Oracle<br />&nbsp; 较复杂, 同时提供GUI和命令行，在windowsNT和unix下操作相同</p>
<p>DB2<br />&nbsp; 操作简单,同时提供GUI和命令行，在windowsNT和unix下操作相同</p>
<p><br />【使用风险】</p>
<p>SQL server<br />&nbsp; 完全重写的代码，经历了长期的测试，不断延迟，许多功能需要时间来证明。并不十分兼容早期产品。使用需要冒一定风险。</p>
<p>Oracle<br />&nbsp; 长时间的开发经验，完全向下兼容。得到广泛的应用。完全没有风险。</p>
<p>DB2<br />&nbsp; 在巨型企业得到广泛的应用，向下兼容性好。风险小。 </p>
<p><br />2003-11-25 11:25:37&nbsp;&nbsp; SQL查询语句使用一、简单查询 <br />&nbsp; 简单的Transact-SQL查询只包括选择列表、FROM子句和WHERE子句。它们分别说明所查询列、查询的表或视图、以及搜索条件等。<br />&nbsp; 例如，下面的语句查询testtable表中姓名为&ldquo;张三&rdquo;的nickname字段和email字段。<br />&nbsp; SELECT nickname,email<br />&nbsp; FROM testtable<br />&nbsp; WHERE name='张三'</p>
<p>(一)选择列表 <br />&nbsp; 选择列表(select_list)指出所查询列，它可以是一组列名列表、星号、表达式、变量(包括局部变量和全局变量)等构成。</p>
<p>&nbsp; 1、选择所有列<br />&nbsp; 例如，下面语句显示testtable表中所有列的数据：<br />&nbsp; SELECT *<br />&nbsp; FROM testtable</p>
<p>&nbsp; 2、选择部分列并指定它们的显示次序<br />&nbsp; 查询结果集合中数据的排列顺序与选择列表中所指定的列名排列顺序相同。<br />&nbsp; 例如：<br />&nbsp; SELECT nickname,email<br />&nbsp; FROM testtable</p>
<p>&nbsp; 3、更改列标题<br />&nbsp; 在选择列表中，可重新指定列标题。定义格式为：<br />&nbsp; 列标题=列名<br />&nbsp; 列名 列标题<br />&nbsp; 如果指定的列标题不是标准的标识符格式时，应使用引号定界符，例如，下列语句使用汉字显示列标题：<br />&nbsp; SELECT 昵称=nickname,电子邮件=email<br />&nbsp; FROM testtable</p>
<p>&nbsp; 4、删除重复行<br />&nbsp; SELECT语句中使用ALL或DISTINCT选项来显示表中符合条件的所有行或删除其中重复的数据行，默认为ALL。使用DISTINCT选项时，对于所有重复的数据行在SELECT返回的结果集合中只保留一行。</p>
<p>&nbsp; 5、限制返回的行数<br />&nbsp; 使用TOP n [PERCENT]选项限制返回的数据行数，TOP n说明返回n行，而TOP n PERCENT时，说明n是表示一百分数，指定返回的行数等于总行数的百分之几。<br />&nbsp; 例如：<br />&nbsp; SELECT TOP 2 *<br />&nbsp; FROM testtable<br />&nbsp; SELECT TOP 20 PERCENT *<br />&nbsp; FROM testtable</p>
<p>(二)FROM子句 <br />&nbsp; FROM子句指定SELECT语句查询及与查询相关的表或视图。在FROM子句中最多可指定256个表或视图，它们之间用逗号分隔。<br />&nbsp; 在FROM子句同时指定多个表或视图时，如果选择列表中存在同名列，这时应使用对象名限定这些列所属的表或视图。例如在usertable和citytable表中同时存在cityid列，在查询两个表中的cityid时应使用下面语句格式加以限定：</p>
<p>&nbsp; SELECT username,citytable.cityid<br />&nbsp;&nbsp;&nbsp; FROM usertable,citytable<br />&nbsp;&nbsp;&nbsp; WHERE usertable.cityid=citytable.cityid<br />&nbsp; 在FROM子句中可用以下两种格式为表或视图指定别名：<br />&nbsp; 表名 as 别名<br />&nbsp; 表名 别名</p>
<p>&nbsp; 例如上面语句可用表的别名格式表示为：<br />&nbsp; SELECT username,b.cityid<br />&nbsp;&nbsp;&nbsp; FROM usertable a,citytable b<br />&nbsp;&nbsp;&nbsp; WHERE a.cityid=b.cityid<br />&nbsp; <br />&nbsp; SELECT不仅能从表或视图中检索数据，它还能够从其它查询语句所返回的结果集合中查询数据。<br />&nbsp; 例如：<br />&nbsp; SELECT a.au_fname+a.au_lname<br />&nbsp;&nbsp;&nbsp; FROM authors a,titleauthor ta<br />&nbsp;&nbsp;&nbsp; (SELECT title_id,title<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM titles<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE ytd_sales&gt;10000<br />&nbsp;&nbsp;&nbsp; ) AS t<br />&nbsp;&nbsp;&nbsp; WHERE a.au_id=ta.au_id<br />&nbsp;&nbsp;&nbsp; AND ta.title_id=t.title_id<br />&nbsp; 此例中，将SELECT返回的结果集合给予一别名t，然后再从中检索数据。</p>
<p>(三)使用WHERE子句设置查询条件 <br />&nbsp; WHERE子句设置查询条件，过滤掉不需要的数据行。例如下面语句查询年龄大于20的数据：<br />&nbsp; SELECT *<br />&nbsp;&nbsp;&nbsp; FROM usertable<br />&nbsp;&nbsp;&nbsp; WHERE age&gt;20</p>
<p>&nbsp; WHERE子句可包括各种条件运算符：<br />&nbsp; 比较运算符(大小比较)：&gt;、&gt;=、=、&lt;、&lt;=、&lt;&gt;、!&gt;、!&lt;<br />&nbsp; 范围运算符(表达式值是否在指定的范围)：BETWEEN&hellip;AND&hellip;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOT BETWEEN&hellip;AND&hellip;<br />&nbsp; 列表运算符(判断表达式是否为列表中的指定项)：IN (项1,项2&hellip;&hellip;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOT IN (项1,项2&hellip;&hellip;)<br />&nbsp; 模式匹配符(判断值是否与指定的字符通配格式相符):LIKE、NOT LIKE<br />&nbsp; 空值判断符(判断表达式是否为空)：IS NULL、NOT IS NULL<br />&nbsp; 逻辑运算符(用于多条件的逻辑连接)：NOT、AND、OR</p>
<p>&nbsp; 1、范围运算符例：age BETWEEN 10 AND 30相当于age&gt;=10 AND age&lt;=30<br />&nbsp; 2、列表运算符例：country IN ('Germany','China')<br />&nbsp; 3、模式匹配符例：常用于模糊查找，它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br />&nbsp; 可使用以下通配字符：<br />&nbsp; 百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br />&nbsp; 下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br />&nbsp; 方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。<br />&nbsp; [^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</p>
<p>&nbsp; 例如：<br />&nbsp; 限制以Publishing结尾，使用LIKE '%Publishing'<br />&nbsp; 限制以A开头：LIKE '[A]%'<br />&nbsp; 限制以A开头外：LIKE '[^A]%'<br />&nbsp; <br />&nbsp; 4、空值判断符例WHERE age IS NULL</p>
<p>&nbsp; 5、逻辑运算符：优先级为NOT、AND、OR</p>
<p>(四)查询结果排序 <br />&nbsp; 使用ORDER BY子句对查询返回的结果按一列或多列排序。ORDER BY子句的语法格式为：<br />&nbsp; ORDER BY {column_name [ASC|DESC]} [,&hellip;n]<br />&nbsp; 其中ASC表示升序，为默认值，DESC为降序。ORDER BY不能按ntext、text和image数据类型进行排序。<br />&nbsp; 例如：<br />&nbsp; SELECT *<br />&nbsp;&nbsp;&nbsp; FROM usertable<br />&nbsp;&nbsp;&nbsp; ORDER BY age desc,userid ASC<br />&nbsp; 另外，可以根据表达式进行排序。</p>
<p>二、联合查询 <br />&nbsp; UNION运算符可以将两个或两个以上上SELECT语句的查询结果集合合并成一个结果集合显示，即执行联合查询。UNION的语法格式为：<br />&nbsp; select_statement<br />&nbsp;&nbsp;&nbsp; UNION [ALL] selectstatement<br />&nbsp;&nbsp;&nbsp; [UNION [ALL] selectstatement][&hellip;n]<br />&nbsp; 其中selectstatement为待联合的SELECT查询语句。<br />&nbsp; ALL选项表示将所有行合并到结果集合中。不指定该项时，被联合查询结果集合中的重复行将只保留一行。<br />&nbsp; 联合查询时，查询结果的列标题为第一个查询语句的列标题。因此，要定义列标题必须在第一个查询语句中定义。要对联合查询结果排序时，也必须使用第一查询语句中的列名、列标题或者列序号。<br />&nbsp; 在使用UNION 运算符时，应保证每个联合查询语句的选择列表中有相同数量的表达式，并且每个查询选择表达式应具有相同的数据类型，或是可以自动将它们转换为相同的数据类型。在自动转换时，对于数值类型，系统将低精度的数据类型转换为高精度的数据类型。<br />&nbsp; 在包括多个查询的UNION语句中，其执行顺序是自左至右，使用括号可以改变这一执行顺序。例如：<br />&nbsp; 查询1 UNION (查询2 UNION 查询3)</p>
<p>三、连接查询 <br />&nbsp; 通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。<br />&nbsp; 在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，尔后通过连接进行查询。<br />&nbsp; 连接可以在SELECT 语句的FROM子句或WHERE子句中建立，似是而非在FROM子句中指出连接时有助于将连接操作与WHERE子句中的搜索条件区分开来。所以，在Transact-SQL中推荐使用这种方法。<br />&nbsp; SQL-92标准所定义的FROM子句的连接语法格式为：<br />&nbsp; FROM join_table join_type join_table<br />&nbsp;&nbsp;&nbsp; [ON (join_condition)]<br />&nbsp; 其中join_table指出参与连接操作的表名，连接可以对同一个表操作，也可以对多表操作，对同一个表操作的连接又称做自连接。<br />&nbsp; join_type 指出连接类型，可分为三种：内连接、外连接和交叉连接。内连接(INNER JOIN)使用比较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。<br />&nbsp; 外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行。<br />&nbsp; 交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。<br />&nbsp; 连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑运算符等构成。<br />&nbsp; 无论哪种连接都不能对text、ntext和image数据类型列进行直接连接，但可以对这三种列进行间接连接。例如：<br />&nbsp; SELECT p1.pub_id,p2.pub_id,p1.pr_info<br />&nbsp;&nbsp;&nbsp; FROM pub_info AS p1 INNER JOIN pub_info AS p2<br />&nbsp;&nbsp;&nbsp; ON DATALENGTH(p1.pr_info)=DATALENGTH(p2.pr_info)</p>
<p>&nbsp; (一)内连接<br />&nbsp; 内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。内连接分三种：<br />&nbsp; 1、等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。<br />&nbsp; 2、不等连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;。<br />&nbsp; 3、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。<br />&nbsp; 例，下面使用等值连接列出authors和publishers表中位于同一城市的作者和出版社：<br />&nbsp; SELECT *<br />&nbsp;&nbsp;&nbsp; FROM authors AS a INNER JOIN publishers AS p<br />&nbsp;&nbsp;&nbsp; ON a.city=p.city</p>
<p>&nbsp; 又如使用自然连接，在选择列表中删除authors 和publishers 表中重复列(city和state)：<br />&nbsp; SELECT a.*,p.pub_id,p.pub_name,p.country<br />&nbsp;&nbsp;&nbsp; FROM authors AS a INNER JOIN publishers AS p<br />&nbsp;&nbsp;&nbsp; ON a.city=p.city</p>
<p>&nbsp; (二)外连接<br />&nbsp; 内连接时，返回查询结果集合中的仅是符合查询条件( WHERE 搜索条件或 HAVING 条件)和连接条件的行。而采用外连接时，它返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左外连接时)、右表(右外连接时)或两个边接表(全外连接)中的所有数据行。<br />&nbsp; 如下面使用左外连接将论坛内容和作者信息连接起来：<br />&nbsp; SELECT a.*,b.* FROM luntan LEFT JOIN usertable as b<br />&nbsp;&nbsp;&nbsp; ON a.username=b.username</p>
<p>&nbsp; 下面使用全外连接将city表中的所有作者以及user表中的所有作者，以及他们所在的城市：<br />&nbsp; SELECT a.*,b.*<br />&nbsp;&nbsp;&nbsp; FROM city as a FULL OUTER JOIN user as b<br />&nbsp;&nbsp;&nbsp; ON a.username=b.username</p>
<p>&nbsp; (三)交叉连接<br />&nbsp; 交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。<br />&nbsp; 例，titles表中有6类图书，而publishers表中有8家出版社，则下列交叉连接检索到的记录数将等于6*8=48行。<br />&nbsp; SELECT type,pub_name<br />&nbsp;&nbsp;&nbsp; FROM titles CROSS JOIN publishers<br />&nbsp;&nbsp;&nbsp; ORDER BY type </p>
<p><br />2003-11-25 11:31:30&nbsp;&nbsp; SQL Server中Image Data Type的使用技巧 【国商网络有限公司 蒋心武】&nbsp;&nbsp; MS SQL Server 是微软公司推出的大型数据库软件，在NT平台上拥有近一半的数据库市场，特别是在SQL Server 7.0推出后，其发展势头更加迅猛。SQL Server中Image数据类型是用来存储图形的。在此我谈谈怎样增、删、改此类型数据及在主页中读出此类型数据。 </p>
<p>&nbsp; 一、在表中添加图形 <br />&nbsp; Image 数据类型不同于其它数据类型，不能用Insert 、Update的标准SQL语法进行图形的添加和修改。需用到SQL Server中的TEXTPTR 、WRITETEXT、UPDATETEXT等函数进行图形的添加和修改。 </p>
<p>&nbsp; 首先假设在库Im_Test中建立一张表Im_Info，此表中有两个字段，分别为Pr_Id （INT），Pr_Info (IMAGE)，用来存储图形编号及图形信息。其语法如下： </p>
<p>CREATE TEALE Im_Info (<br />&nbsp; Pr_Id INT NULL ，<br />&nbsp; Pr_Info IMAGE NULL<br />)</p>
<p>&nbsp; 第一步往表中插入一条记录，并初始化PR_INFO字段。其语法如下： </p>
<p>INSERT INTO Im_Info VALUES （1 ，0xFFFFFFFF）</p>
<p>&nbsp; 第二步往表中写入图形信息。其语法如下： </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE @@ptrval varbinary(16)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT @@ptrval = TEXTPTR(Pr_Info) <br />&nbsp; FROM Im_Info<br />&nbsp; WHERE Pr_Id = 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITETEXT Im_Text.Im_Info <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@ptrval 0x624fd543fd&hellip;..</p>
<p>&nbsp; 其中0x624fd543fd&hellip;.. 为图形的十六进制数据，可以通过C 、Java等工具获得。注意在写入图形信息前必须先将此数据库的 'select into/bulkcopy' 属性设置为 True ，其语法如下： </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sp_dboption Im_Test ，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'select into/bulkcopy' ，True</p>
<p>&nbsp; 若想修改图形数据可用UPDATETEXT函数修改，其语法如下： </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE @@ptrval varbinary(16)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT @@ptrval = TEXTPTR(Pr_Info) <br />&nbsp;&nbsp;&nbsp; FROM Im_Info<br />&nbsp; WHERE Pr_Id = 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPDATETEXT Im_Text.Im_Info <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@ptrval 0xaa31bcfe543fd&hellip;..</p>
<p>&nbsp; 二、在主页中显示图形 </p>
<p>&nbsp; 第一步建立数据源 <br />&nbsp; 若想将加入的图形显示在主页中，必须先建立数据源，打开Windows 中的控制面板。通过ODBC 应用程序，建立数据源（取名Im_Test）连接到Im_Test数据库 </p>
<p>&nbsp; 第二步编写程序 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; % @ LANGUAGE = VBScript % &gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; % Option Explicit % &gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; %<br />Dim oConn&nbsp;&nbsp; <br />Dim oRs&nbsp;&nbsp; <br />Dim Pic&nbsp;&nbsp; <br />Dim PicSize&nbsp;&nbsp; </p>
<p>Response.Buffer = TRUE<br />Response.ContentType = &quot;image/gif&quot;</p>
<p>Set oConn = Server.CreateObject (&quot;ADODB.Connection&quot;)<br />oConn.Open &quot;Im_Test&quot;,&rdquo;sa&rdquo;,&rdquo;&rdquo;<br />Set oRs = oConn.Execute(&quot;SELECT Pr_Info FROM Im_Info WHERE Pr_Id=1&rdquo;)</p>
<p>PicSize = oRs(&quot;Pr_Info&quot;).ActualSize<br />Pic = oRs(&quot;Pr_Info &quot;).GetChunk(PicSize)</p>
<p>Response.BinaryWrite Pic<br />Response.End<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % &gt;</p>
<p>&nbsp; 此程序中先定义四个变量。然后设置属性 Response.Buffer=TRU和Response.ContentType = &quot;image/gif&quot; ，再连接数据库取出图形，在加以显示。 </p>
<p><br />2003-11-25 11:41:44&nbsp;&nbsp; 深入SQL编程【关于存储过程和索引】　　这里所指的SQL编程并不是那些在象ASP，PHP脚本语言里用的某个SQL语句，如果你是个程序员并在做DB C/S开发，我想你会很清楚的知道SQL编程是很复杂的，先抛开嵌入语句，动态执行，高级函数，表达试等这些不谈单就解决性能问题就很头疼，下面就性能问题给出一些解决放案.（以下程序均在NT+SP6 SQL SERVER 7下调试通过） </p>
<p>一，存储过程 <br />&nbsp; 我的一个朋友用VC/SQL SERVER做C/S项目开发，再开发过程中他的程序虽顺利执行，但遇到了由于需要大批量插入数据而引出的性能问题。他找到了我，虽然我没有用过VC但很明显在他程序中看出是在前台用循环操作象后台插入数据。这种方法再处理大批量数时无疑是不可取的，因编译器并不会处理SQL语句而是通过ODBC传输到后台，再在后台解释执行。 <br />&nbsp; 由此可见经过以上几步性能问题以大打折扣，后我将他的程序段改为后台SQL编程，用存储过程实现。然后在前台用VC调用，这样一来问题以得到完美的解决。改后程序如下：（遇到此类问题的朋友可参考解决） </p>
<p>CREATE PROC usp_insert_temp <br />@iCount VARCHAR(10), <br />@Text VARCHAR(50), <br />@price VARCHAR(15) </p>
<p>AS </p>
<p>DECLARE @iIndex INT <br />DECLARE @pMoney FLOAT </p>
<p>SET @iIndex=CONVERT(INT,@iCount) <br />SET @pMoney=CONVERT(FLOAT,@price) </p>
<p>BEGIN TRAN <br />SELECT rygl_id,title,price <br />INTO rygl_temp FROM rqk <br />WHERE EXISTS <br />(SELECT rygl_id <br />FROM rygl <br />WHERE rqk.rygl_id=rygl.rygl_id <br />AND qty&lt;30) <br />ORDER BY title_id </p>
<p>IF @@ERROR&lt;&gt;0 <br />ROLLBACK TRAN <br />ELSE <br />COMMIT TRAN </p>
<p>WHILE @iIndex&gt;0 <br />BEGIN <br />BEGIN TRAN <br />SET @pMoney=@pMoney+1.1111 <br />INSERT INTO rygl_temp(rygl_id,title,price) <br />VALUES(@iIndex,@Text,CONVERT(SMALLMONEY,@pMoney)) </p>
<p>IF @@ERROR&lt;&gt;0 OR @@ROWCOUNT=0 <br />ROLLBACK TRAN <br />ELSE <br />COMMIT TRAN <br />SET @iIndex=@iIndex-1 <br />END </p>
<p>二，索引测试，比较 <br />&nbsp; 合理的索引建立，运用可很大幅度提高程序性能，以下是在工作当中得出的经验，与大家共享。 </p>
<p>1,ORDER BY和GROPU BY <br />&nbsp; 如果用户经常选择数据和使用ORDER BY和GROUP BY短语，任何一种索引都有助于SELECT的性能提高。如果用户选择的是顾客并按其姓名分类，两种索引都能快速检索数据。但下面的一些因素会使用户选择使用某一种索引。 </p>
<p>2,返回范围内的数据 <br />&nbsp; 列如，如果拥护希望返回在SMITH和TALBERT之间的所有顾客姓名，或者返回在日期&ldquo;11/1/98&rdquo;和&ldquo;11/30/98&rdquo;之间的订货量，并且用户经常做这类事情，那么最好在该范围所在的指定列使用聚类索引。因聚类索引已包含了经过分类排序的数据，这对于在指定范围内检索数据更为有效。聚类索引只需找到要检索的所有数据中的开头和结尾数据即可；而不象非聚类索，必须在数据层专查找来字叶层的每一个数据项。 </p>
<p>3,列中有一个或极少的不同值 <br />&nbsp; 在用户表中的某些列中喊有极少不同值，列如状态列中只包含INACVTIVE，ACVIVE或者TERMINATED。在这种情况下，在该列上使用任何类型索引都是不明智的，原因很简单：如果用户表包含了1500行大概有三分之一的行即500行在状态列中含有ACTIVE。扫描整个表，如果不是更高效，至少也是同先在索引页面中查找每个数据项而后寻找到包含ACTIVE状态的行所在的数 <br />据页面也相同的效率。下面这个列子创建了一个表，它在有很很多重复值的列上进行索引，而该列具有很少的不同值。运行该脚本可能要花几分钟。 </p>
<p>*/ </p>
<p>DROP TABLE IndexTestTable <br />CREATE TABLE IndexTestTable <br />( <br />Tid INT IDENTITY(1,1) NOT NULL, <br />Status CHAR(10) NULL <br />) </p>
<p>GO </p>
<p>SET IDENTITY_INSERT IndexTestTable ON <br />DECLARE @intCount INT </p>
<p>BEGIN TRAN <br />SET @intCount=1 <br />WHILE @intCount&lt;=1500 <br />BEGIN <br />INSERT IndexTestTable(Tid,Status) VALUES(@intCount,'Active') <br />SET @intCount=@intCount+3 <br />END </p>
<p>SET @intCount=2 <br />WHILE @intCount&lt;=1500 <br />BEGIN <br />INSERT IndexTestTable(Tid,Status) VALUES(@intCount,'inactive') <br />SET @intCount=@intCount+3 <br />END </p>
<p>SET @intCount=3 <br />WHILE @intCount&lt;=1500 <br />BEGIN <br />INSERT IndexTestTable(Tid,Status) VALUES(@intCount,'Terminated') <br />SET @intCount=@intCount+3 <br />END <br />COMMIT TRAN </p>
<p>SET IDENTITY_INSERT IndexTestTable OFF <br />GO </p>
<p>DUMP TRANSACTION pubs WITH NO_LOG <br />GO </p>
<p>CREATE INDEX inTableUniquesStatus <br />ON IndexTestTable(Status) <br />GO </p>
<p>--不用索引查询 <br />SELECT * <br />FROM IndexTestTable WITH(index(0)) <br />WHERE Status='inactive' </p>
<p>--用索引查询 <br />SELECT * <br />FROM IndexTestTable WITH(index(inTableUniquesStatus)) <br />WHERE Status='inactive' </p>
<p>/* </p>
<p>&nbsp; 选中SHOW STATS I/O查看运行结果会另人吃惊。第一个SELECT语句引起全表扫描几乎不需要内存操作(因为只是进行插入，所有所有数据都在内存中，并不需要进行磁盘或物理读操作)。第二个SELECT语句则需要执行500个读操作,这就证实了我们所说的在这种情况下,使用任何类型索引都是不明智的。 </p>
<p>4，<br />&nbsp; 以上举列说明了在何种情况下不应使用索引，现在咱们再反过来看看当索引列中 <br />不同数目值增加时即有较少不同值时会怎样？见如下代码</p>
<p>*/ </p>
<p>DROP TABLE IndexTestTable <br />GO </p>
<p>CREATE TABLE IndexTestTable <br />( <br />Tid INT IDENTITY(1,1) NOT NULL, <br />Status CHAR(10) NULL, <br />Co3 CHAR(20) NOT NULL, <br />Co4 CHAR(50) NOT NULL <br />) <br />GO </p>
<p>DECLARE @intNum INT <br />SET @intNum=0 </p>
<p>BEGIN TRAN <br />WHILE @intNum&lt;=1300 <br />BEGIN <br />INSERT indexTestTable <br />VALUES(CHAR(@intNum %26 +65),'test3','test4') <br />SET @intNum=@intNum+1 <br />END <br />COMMIT TRAN <br />GO </p>
<p>--不用索引查询 <br />SELECT * FROM IndexTestTable WHIT(INDEX(0)) <br />WHERE Status='B' </p>
<p>--创建聚集索引 <br />CREATE CLUSTERED INDEX icIndexTestTable <br />ON IndexTestTable(Status) <br />GO </p>
<p>--使用索引查询 <br />SELECT * FROM IndexTestTable WITH(INDEX(icIndexTestTable)) <br />WHERE Status='B' </p>
<p>/* </p>
<p>5， <br />&nbsp; 用户很明显地能看出，随着表中行的数目和列中不同值的增长。使用索引可以较大幅度提高效率，由此又引出另一个问题，在何种情况下用何种索引更有效？上面列子已经介绍了聚类索引，大家都能看出在对于有较少不同植时使用聚类索引是有很大帮助的，但当不同值的数木增加并达到表中行的树木时则应该选非聚类索引。此时使用非聚类索在读操作上和聚类似索引并无 <br />二异，但在对表进行写操作上的性能却提高不少，如果用户经常从表中的一个或少是数几个字段中检索数据，当非聚集索引包含要检索的所有字段时就会减少所需的读操作，如果不是那么正如上面第二条所说使用非聚集索引通常是钟很差的选择，下面这个列子说明了在何时应该使用聚集索引</p>
<p>*/ </p>
<p>DROP TABLE IndexTestTable <br />GO </p>
<p>CREATE TABLE IndexTestTable <br />( <br />Tid INT IDENTITY(1,1)NOT NULL, <br />Status CHAR(20) NOT NULL <br />) <br />GO </p>
<p>DECLARE @intCount INT <br />SET @intCount=0 </p>
<p>BEGIN TRAN <br />WHILE @intCount&lt;=500 <br />BEGIN <br />INSERT INTO IndexTestTable(Status) VALUES('test'+CONVERT(CHAR(6),@intCount)) <br />SET @intCount=@intCount+1 <br />END <br />COMMIT TRAN <br />GO </p>
<p>--创建聚集索引 <br />CREATE CLUSTERED INDEX icIndexTestTable <br />ON IndexTestTable(Tid) <br />GO </p>
<p>--创建非聚集索引 <br />CREATE INDEX inIndexTestTable <br />ON IndexTestTable(Tid) <br />GO </p>
<p>--使用非聚集索引查询 <br />SELECT Tid FROM IndexTestTable WITH(INDEX(inIndexTestTable)) <br />WHERE Tid BETWEEN 100 AND 500 </p>
<p>--使用聚集索引查询 <br />SELECT Tid FROM IndexTestTable WITH(INDEX(icIndexTestTable)) <br />WHERE Tid BETWEEN 100 AND 500 </p>
<p>/* </p>
<p>&nbsp; 集索引包含绝大多数的检索数据，则只需要读取很少的数据页这种情况下非聚集索引要比聚集索引好，如果表的数据行很庞大效果会更加明显。</p>
<p>6， <br />&nbsp; 要说明的是，索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。 </p>
<p><br />2003-11-25 11:49:45&nbsp;&nbsp; SQL Server日期计算&nbsp;&nbsp; 通常，你需要获得当前日期和计算一些其他的日期，例如，你的程序可能需要判断一个月的第一天或者最后一天。你们大部分人大概都知道怎样把日期进行分割（年、月、日等），然后仅仅用分割出来的年、月、日等放在几个函数中计算出自己所需要的日期！在这篇文章里，我将告诉你如何使用DATEADD和DATEDIFF函数来计算出在你的程序中可能你要用到的一些不同日期。 <br />在使用本文中的例子之前，你必须注意以下的问题。大部分可能不是所有例子在不同的机器上执行的结果可能不一样，这完全由哪一天是一个星期的第一天这个设置决定。第一天（DATEFIRST）设定决定了你的系统使用哪一天作为一周的第一天。所有以下的例子都是以星期天作为一周的第一天来建立，也就是第一天设置为7。假如你的第一天设置不一样，你可能需要调整这些例子，使它和不同的第一天设置相符合。你可以通过@@DATEFIRST函数来检查第一天设置。</p>
<p>&nbsp; 为了理解这些例子，我们先复习一下DATEDIFF和DATEADD函数。DATEDIFF函数计算两个日期之间的小时、天、周、月、年等时间间隔总数。DATEADD函数计算一个日期通过给时间间隔加减来获得一个新的日期。要了解更多的DATEDIFF和DATEADD函数以及时间间隔可以阅读微软联机帮助。</p>
<p>&nbsp; 使用DATEDIFF和DATEADD函数来计算日期，和本来从当前日期转换到你需要的日期的考虑方法有点不同。你必须从时间间隔这个方面来考虑。比如，从当前日期到你要得到的日期之间有多少时间间隔，或者，从今天到某一天（比如1900-1-1）之间有多少时间间隔，等等。理解怎样着眼于时间间隔有助于你轻松的理解我的不同的日期计算例子。</p>
<p>【一个月的第一天】<br />&nbsp; 第一个例子，我将告诉你如何从当前日期去这个月的最后一天。请注意：这个例子以及这篇文章中的其他例子都将只使用DATEDIFF和DATEADD函数来计算我们想要的日期。每一个例子都将通过计算但前的时间间隔，然后进行加减来得到想要计算的日期。</p>
<p>&nbsp; 这是计算一个月第一天的SQL 脚本：<br />&nbsp; SELECT DATEADD(mm, DATEDIFF(mm,0,getdate()), 0)</p>
<p>&nbsp; 我们把这个语句分开来看看它是如何工作的。最核心的函数是getdate()，大部分人都知道这个是返回当前的日期和时间的函数。下一个执行的函数DATEDIFF(mm,0,getdate())是计算当前日期和&ldquo;1900-01-01 00:00:00.000&rdquo;这个日期之间的月数。记住：时期和时间变量和毫秒一样是从&ldquo;1900-01-01 00:00:00.000&rdquo;开始计算的。这就是为什么你可以在DATEDIFF函数中指定第一个时间表达式为&ldquo;0&rdquo;。下一个函数是DATEADD，增加当前日期到&ldquo;1900-01-01&rdquo;的月数。通过增加预定义的日期&ldquo;1900-01-01&rdquo;和当前日期的月数，我们可以获得这个月的第一天。另外，计算出来的日期的时间部分将会是&ldquo;00:00:00.000&rdquo;。</p>
<p>&nbsp; 这个计算的技巧是先计算当前日期到&ldquo;1900-01-01&rdquo;的时间间隔数，然后把它加到&ldquo;1900-01-01&rdquo;上来获得特殊的日期，这个技巧可以用来计算很多不同的日期。下一个例子也是用这个技巧从当前日期来产生不同的日期。</p>
<p>【本周的星期一】<br />&nbsp; 这里我是用周(wk)的时间间隔来计算哪一天是本周的星期一。<br />&nbsp; SELECT DATEADD(wk, DATEDIFF(wk,0,getdate()), 0)</p>
<p>【一年的第一天】<br />&nbsp; 现在用年(yy)的时间间隔来显示这一年的第一天。<br />&nbsp; SELECT DATEADD(yy, DATEDIFF(yy,0,getdate()), 0)</p>
<p>【季度的第一天】<br />&nbsp; 假如你要计算这个季度的第一天，这个例子告诉你该如何做。<br />&nbsp; SELECT DATEADD(qq, DATEDIFF(qq,0,getdate()), 0)</p>
<p>【当天的半夜】<br />&nbsp; 曾经需要通过getdate()函数为了返回时间值截掉时间部分，就会考虑到当前日期是不是在半夜。假如这样，这个例子使用DATEDIFF和DATEADD函数来获得半夜的时间点。<br />&nbsp; SELECT DATEADD(dd, DATEDIFF(dd,0,getdate()), 0)</p>
<p>【深入DATEDIFF和DATEADD函数计算】<br />&nbsp; 你可以明白，通过使用简单的DATEDIFF和DATEADD函数计算，你可以发现很多不同的可能有意义的日期。</p>
<p>&nbsp; 目前为止的所有例子只是仅仅计算当前的时间和&ldquo;1900-01-01&rdquo;之间的时间间隔数量，然后把它加到&ldquo;1900-01-01&rdquo;的时间间隔上来计算出日期。假定你修改时间间隔的数量，或者使用不同的时间间隔来调用DATEADD函数，或者减去时间间隔而不是增加，那么通过这些小的调整你可以发现和多不同的日期。</p>
<p>&nbsp; 这里有四个例子使用另外一个DATEADD函数来计算最后一天来分别替换DATEADD函数前后两个时间间隔。</p>
<p>【上个月的最后一天】<br />&nbsp; 这是一个计算上个月最后一天的例子。它通过从一个月的最后一天这个例子上减去3毫秒来获得。有一点要记住，在Sql Server中时间是精确到3毫秒。这就是为什么我需要减去3毫秒来获得我要的日期和时间。<br />&nbsp; SELECT dateadd(ms,-3,DATEADD(mm, DATEDIFF(mm,0,getdate()), 0))</p>
<p>&nbsp; 计算出来的日期的时间部分包含了一个Sql Server可以记录的一天的最后时刻(&ldquo;23:59:59:997&rdquo;)的时间。</p>
<p>【去年的最后一天】<br />&nbsp; 连接上面的例子，为了要得到去年的最后一天，你需要在今年的第一天上减去3毫秒。<br />&nbsp; SELECT dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate()), 0))</p>
<p>【本月的最后一天】<br />&nbsp; 现在，为了获得本月的最后一天，我需要稍微修改一下获得上个月的最后一天的语句。修改需要给用DATEDIFF比较当前日期和&ldquo;1900-01-01&rdquo;返回的时间间隔上加1。通过加1个月，我计算出下个月的第一天，然后减去3毫秒，这样就计算出了这个月的最后一天。这是计算本月最后一天的SQL脚本。<br />&nbsp; SELECT dateadd(ms,-3,DATEADD(mm, DATEDIFF(m,0,getdate())+1, 0))</p>
<p>【本年的最后一天】<br />&nbsp; 你现在应该掌握这个的做法，这是计算本年最后一天脚本<br />&nbsp; SELECT dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate())+1, 0))。</p>
<p>【本月的第一个星期一】<br />&nbsp; 好了，现在是最后一个例子。这里我要计算这个月的第一个星期一。这是计算的脚本。 <br />&nbsp; select DATEADD(wk, DATEDIFF(wk,0,dateadd(dd,6-datepart(day,getdate()),getdate())), 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp; 在这个例子里，我使用了&ldquo;本周的星期一&rdquo;的脚本，并作了一点点修改。修改的部分是把原来脚本中&ldquo;getdate()&rdquo;部分替换成计算本月的第6天，在计算中用本月的第6天来替换当前日期使得计算可以获得这个月的第一个星期一。</p>
<p>【总结】<br />&nbsp; 我希望这些例子可以在你用DATEADD和DATEDIFF函数计算日期时给你一点启发。通过使用这个计算日期的时间间隔的数学方法，我发现为了显示两个日期之间间隔的有用历法是有价值的。注意，这只是计算出这些日期的一种方法。要牢记，还有很多方法可以得到相同的计算结果。假如你有其他的方法，那很不错，要是你没有，我希望这些例子可以给你一些启发，当你要用DATEADD和DATEDIFF函数计算你程序可能要用到的日期时。 </p>
<p><br />2003-11-25 12:11:33&nbsp;&nbsp;&nbsp;&nbsp; 在数据库管理系统中，查询是一项必不可少的功能。查询功能是直接体现系统功能的一项重要指标。查询的方式主要有以下几种：1固定字段的单一查询；2可选择字段的单一查询；3限制若干个字段的多重查询；4可任意选择字段的多重查询。前两种也称为单条件查询，后两种称为多重（或多条件）查询。在实际中，系统（实为程序员）提供给用户的查询方式以单条件查询为多，即使提供了多条件方式，通常也只有两或三个条件，因为编写多重查询是一项非常棘手且繁琐的事情。仅为此，程序员吃尽了苦头。实际上，利用表格Grid功能，就能轻松地实现多重查询。本人以Delphi为例，介绍具体的实现方法，但这种思想，也同样适合于其它的编程语言（如Visual Foxpro）。</p>
<p>&nbsp; 另外，为使程序方便&ldquo;移植&rdquo;， 本人把各功能模块化，使其更具有通用性。</p>
<p>程序主要按如下三个功能来实现：<br />①设置DBGrid<br />②生成查询条件（语句）<br />③执行查询</p>
<p>具体步骤如下：<br />⑴新建一工程文件，取名为PDBGrid.dpr；<br />⑵给单元文件取名为UDBGrid.pas，在其相应的表单（取名为frmDBGrid）中添加如下控件并编写相应的代码：</p>
<p>控件名称<br />主要属性及值<br />备注<br />Table1<br />DataBaseName(MyAlias)<br />TableName<br />(MyTable1.db)<br />Active<br />(false)<br />查询对象：数据集<br />MyTable1.db为任意的表<br />DataSource1<br />DataSet(Table1)</p>
<p>DBGrid1<br />DataSource（DataSource1）</p>
<p>显示数据源<br />Table2<br />DataBaseName(MyAlias)<br />TableName<br />(CxComm.db)<br />Active<br />(false)</p>
<p>记录查询条件的数据集<br />（CxComm.db结构下述）<br />DataSource2<br />DataSet(Table2)</p>
<p>DBGrid2<br />DataSource（DataSource2）</p>
<p>提供查询处理<br />Query1<br />DataBaseName(MyAlias)<br />Active<br />(false)</p>
<p>保存和执行SQL语句的数据集<br />DataSource3<br />DataSet<br />(Query 1)</p>
<p>DGrid3<br />DataSource<br />(DataSource3)</p>
<p>显示查询结果<br />Memo1<br />Lines（&lt;动态赋值&gt;）</p>
<p>显示及修改SQL语句<br />Button1<br />Caption(设置DBGrid)</p>
<p>Click事件下述<br />Button2<br />Caption(生成查询)</p>
<p>Click事件下述<br />Button3<br />Caption（执行查询)</p>
<p>Click事件下述</p>
<p>其中<br />Table2（记录查询条件的数据集）对应的表CxComm.db的结构定义如下：</p>
<p>字段名<br />项目<br />关系<br />实例<br />逻辑<br />类型<br />A（字符型）<br />A（字符型）<br />A（字符型）<br />A（字符型）<br />大小<br />14<br />5<br />10<br />6</p>
<p>表单的FormActivate事件代码如下：<br />procedure TfrmDBGrid.FormActivate(Sender: TObject);<br />begin<br />if Table2.Active then Table2.Close;<br />Table2.EmptyTable; //清空条件<br />Table1.Open;<br />Table2.Open;<br />end;</p>
<p>Button1(设置DBGrid)的Click事件代码如下：<br />procedure TfrmDBGrid.Button1Click(Sender: TObject);<br />begin<br />MySetDBGrid(Table1,DBGrid2); // MySetDBGrid为自定义过程<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //以Table1为数据源,DBGrid2为记录筛选（查询）条件的表格<br />end;</p>
<p>Button2(生成查询)的Click事件代码如下：<br />procedure TfrmDBGrid.Button2Click(Sender: TObject);<br />begin<br />if MyCreate_SQL(Table1,Table2,Query1) //MyCreate_SQL为自定义函数<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //由指定数据来源表来生成SQL,存入Query1<br />then begin<br />&nbsp; Memo1.Lines.Clear;<br />&nbsp; Memo1.Lines:=(Query1.SQL);<br />&nbsp; Memo1.Modified:=false;<br />end<br />end;</p>
<p>Button3(执行查询)的Click事件代码如下：<br />procedure TfrmDBGrid.Button3Click(Sender: TObject);<br />begin<br />with Query1,SQL do<br />begin<br />&nbsp; Close;<br />&nbsp; if Memo1.Modified //用户可修改SQL语句<br />&nbsp; then SQL:=Memo1.Lines;<br />&nbsp; try<br />&nbsp;&nbsp;&nbsp; ExecSQL;<br />&nbsp;&nbsp;&nbsp; Open;<br />&nbsp; except //捕捉错误并处理<br />&nbsp;&nbsp;&nbsp; begin<br />&nbsp;&nbsp;&nbsp; MessageBeep(0);<br />&nbsp;&nbsp;&nbsp; Application.MessageBox('错误的SQL语句！','确认',MB_OK+MB_ICONSTOP);<br />&nbsp;&nbsp;&nbsp; Close;<br />&nbsp;&nbsp;&nbsp; end;<br />&nbsp; end //try<br />end;<br />end; //执行SQL</p>
<p>自定义过程MySetDBGrid (设置DBGrid)的代码如下：<br />procedure TfrmDBGrid.MySetDBGrid(sTable:TTable;tjDBGrid:TDBGrid);<br />//参数说明：sTable为数据（包括字段，记录）来源表<br />// tjDBGrid为记录筛选（查询）条件的表格<br />var i:byte;<br />begin<br />//设置查询项目<br />if not sTable.Active then sTable.Open;<br />tjDBGrid.Columns[0].PickList.Clear;<br />for i:=0 to sTable.FieldCount-1 do //记录数(即字段数)<br />begin<br />&nbsp; tjDBGrid.Columns[0].PickList.Add(sTable.Fields.FieldName);<br />end; //for<br />//设置关系(=,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;=) 及逻辑(AND,OR)<br />tjDBGrid.Columns[1].PickList.Text:='='+#13+'&lt;&gt;'+#13+'&gt;'+#13+'&gt;='+#13+'&lt;'+#13+'&lt;=';<br />tjDBGrid.Columns[3].PickList.Text:='AND'+#13+'OR';<br />end;//设置DBGrid</p>
<p>自定义函数MyCreate_SQL (生成查询)的代码如下：<br />function TfrmDBGrid.MyCreate_SQL(sTable,tjTable:TTable;tjQuery:TQuery):boolean;<br />//参数说明：sTable为数据（包括字段，记录）来源表<br />// tjTable为记录筛选（查询）条件的表<br />// tjQuery记录SQL语句<br />var i:byte;<br />&nbsp; lsDate:TDate; //检测日期格式用<br />&nbsp; sLj,sFilter,sFieldName:string; //分别表示:逻辑关系,筛选条件,字段名<br />begin<br />Result:=true;<br />//生成&quot;筛选条件&quot;语句<br />with tjQuery,SQL do<br />begin <br />&nbsp; Close;<br />&nbsp; Clear;<br />&nbsp; DatabaseName:=sTable.DatabaseName; //设置Query1的别名<br />&nbsp; Add('Select * from '''+sTable.TableName+'''');<br />end;<br />with tjTable do //查询(筛选)条件表<br />begin<br />&nbsp; if not Active then Open;<br />&nbsp; if IsEmpty<br />&nbsp; then begin<br />&nbsp;&nbsp;&nbsp; Application.MessageBox('未选择筛选条件！','确定',MB_OK+MB_ICONEXCLAMATION);<br />&nbsp;&nbsp;&nbsp; Exit;<br />&nbsp; end;<br />&nbsp; tjQuery.SQL.Add(' Where ');//含有筛选条件<br />&nbsp; sFilter:=''; //临时记录筛选条件<br />&nbsp; First;<br />&nbsp; for i:=0 to RecordCount-1 do<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; sLj:=Fields[3].AsString; //逻辑关系AND,OR<br />&nbsp;&nbsp;&nbsp; //(字段名0&gt;1实际值2)<br />&nbsp;&nbsp;&nbsp; sFilter:=sFilter+'(';<br />&nbsp;&nbsp;&nbsp; sFilter:=sFilter+Fields[0].AsString+Fields[1].AsString;<br />&nbsp;&nbsp;&nbsp; sFieldName:=Fields[0].AsString; //取第1列的字段名<br />&nbsp;&nbsp;&nbsp; case Table1.FieldByName(sFieldName).DataType of ftString: <br />&nbsp;&nbsp;&nbsp; begin //字符型处理<br />&nbsp;&nbsp;&nbsp; sFilter:=sFilter+''''+Fields[2].AsString+'''' //第2列为关系<br />&nbsp;&nbsp;&nbsp; end;<br />&nbsp;&nbsp;&nbsp; ftFloat, //浮点型处理<br />&nbsp;&nbsp;&nbsp; ftAutoInc, //自增型<br />&nbsp;&nbsp;&nbsp; ftSmallInt, //短整型<br />&nbsp;&nbsp;&nbsp; ftInteger, //整型<br />&nbsp;&nbsp;&nbsp; ftCurrency: begin //货币型<br />&nbsp;&nbsp;&nbsp; sFilter:=sFilter+Fields[2].AsString;<br />&nbsp; end;<br />&nbsp; ftDate: <br />&nbsp;&nbsp;&nbsp; begin //日期型处理<br />&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lsDate:=StrToDate(Fields[2].AsString);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sFilter:=sFilter+''''+FormatDateTime('mm/dd/yyyy',StrToDate(Fields[2].AsString))+'''';<br />&nbsp;&nbsp;&nbsp; except<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application.MessageBox('错误的日期格式！','确认',MB_OK+MB_ICONSTOP);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result:=false; //返回错误标志<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp; end;//try 日期格式判断<br />&nbsp;&nbsp;&nbsp; end;<br />&nbsp;&nbsp;&nbsp; //此处可增加对其它类型数据的处理<br />&nbsp;&nbsp;&nbsp; end;//case<br />&nbsp;&nbsp;&nbsp; sFilter:=sFilter+')';<br />&nbsp;&nbsp;&nbsp; if sLj&lt;&gt;''<br />&nbsp;&nbsp;&nbsp; then begin<br />&nbsp;&nbsp;&nbsp; if RecNo&lt;&gt;RecordCount //且&quot;非最后行&quot;的记录<br />&nbsp;&nbsp;&nbsp; then sFilter:=sFilter+Fields[3].AsString; //And|Or;<br />&nbsp;&nbsp;&nbsp; end<br />&nbsp;&nbsp;&nbsp; else break;<br />&nbsp;&nbsp;&nbsp; Next<br />&nbsp; end;<br />end; //not IsEmpty(筛选)非空<br />tjQuery.SQL.Add(sFilter); //保存查询条件<br />end; //处理筛选条件</p>
<p>另外，需要进行如下说明：<br />...<br />Type<br />...<br />procedure MySetDBGrid(sTable:TTable;tjDBGrid:TDBGrid);<br />function MyCreate_SQL(sTable,tjTable:TTable;tjQuery:TQuery):boolean;<br />private<br />{ Private declarations }<br />...</p>
<p>&nbsp; 值得说明的是，⑴为从一定程序上简化程序，逻辑关系只提供了AND和OR两种，但为允许用户修改SQL语句，如：在多条件之间增加括号来改变运算顺序等，使得查询功能更加强大，因此增加了Memo控件；⑵在实际系统中，为方便用户的操作，可增加几个Button（按钮），功能分别是对Table2的&ldquo;增加&rdquo;、&ldquo;删除&rdquo;，这样用户界面会更友好些。<br />利用这种方法来设置查询，条件个数是无限制的，且在屏幕上不会占据太大的空间，程序员实现起来要简单得多了。</p>
<p>软件环境：中文Win98/中文Delphi5.0。 </p>
<p><br />2003-11-25 12:39:56&nbsp;&nbsp; 有关重复记录的删除&nbsp;&nbsp; 有两个意义上的重复记录，一是完全重复的记录，也即所有字段均重复的记录，二是部分关键字段重复的记录，比如Name字段重复，而其他字段不一定重复或都重复可以忽略。</p>
<p>1、对于第一种重复，比较容易解决，使用<br />&nbsp; select distinct * from tableName<br />就可以得到无重复记录的结果集。<br />&nbsp; 如果该表需要删除重复的记录（重复记录保留1条），可以按以下方法删除<br />&nbsp; select distinct * into #Tmp from tableName<br />&nbsp; drop table tableName<br />&nbsp; select * into tableName from #Tmp<br />&nbsp; drop table #Tmp<br />发生这种重复的原因是表设计不周产生的，增加唯一索引列即可解决。</p>
<p>2、这类重复问题通常要求保留重复记录中的第一条记录，操作方法如下假设有重复的字段为Name,Address，要求得到这两个字段唯一的结果集<br />&nbsp; select identity(int,1,1) as autoID, * into #Tmp from tableName<br />&nbsp; select min(autoID) as autoID into #Tmp2 from #Tmp group by Name,autoID<br />&nbsp; select * from #Tmp where autoID in(select autoID from #tmp2)<br />最后一个select即得到了Name，Address不重复的结果集（但多了一个autoID字段，实际写时可以写在select子句中省去此列） </p>
<p><br />2003-11-25 13:15:26&nbsp;&nbsp; SQL SERVER 2000 数据库备份与恢复单元unit BackRestoreSQLDB;<br />{描述：SQL SERVER 2000 数据库备份与恢复单元 ,本单元函数在SQL SERVER 2000 +Delphi7.0编译通过<br />时间：2003.09.15<br />作者：chenshaizi<br />}<br />interface</p>
<p>uses<br />adodb, db;<br />function repl_substr(sub_old, sub_new, s: string): string; //把sub_old换成sub_new,后面有用。<br />function BackupSQLDataBase(connstr_sql, DatabaseName, Backup_FileName: string): Boolean; //数据库备份函数<br />//SQL数据数据库备份，connstr_sql是ADO控件的connectionstring,DatabaseName是数据库名称，<br />//Backup_FileName要备份到的目 标文件<br />function RestoreSQLDataBase(connstr_sql, DatabaseName, Restore_FileName: string): Boolean; //数据库恢复函数<br />//Restore_FileName以前备份的数据库文件，<br />implementation</p>
<p>function repl_substr(sub_old, sub_new, s: string): string;<br />var<br />i: integer;<br />begin<br />repeat<br />&nbsp; i := pos(sub_old, s);<br />&nbsp; if i &gt; 0 then<br />&nbsp; begin<br />&nbsp;&nbsp;&nbsp; delete(s, i, Length(sub_old));<br />&nbsp;&nbsp;&nbsp; insert(sub_new, s, i);<br />&nbsp; end;<br />until i &lt; 1;<br />Result := s;<br />end;</p>
<p>function BackupSQLDataBase(connstr_sql, DatabaseName, Backup_FileName: string): Boolean;<br />var<br />//备份SQL数据库SQL数据数据库备份，connstr_sql是ADO控件的connectionstring,DatabaseName是数据库名称，<br />//Backup_FileName要备份到的目标文件<br />aADOQuery: TADOQuery;<br />begin<br />try<br />&nbsp; aADOQuery := TADOQuery.Create(nil);<br />&nbsp; aADOQuery.Close;<br />&nbsp; aADOQuery.ConnectionString := connstr_sql;<br />&nbsp; aADOQuery.SQL.Clear;<br />&nbsp; aADOQuery.SQL.Add('backup database ' + DatabaseName + ' to disk = ' + '''' + Backup_FileName + ''' with format');<br />&nbsp; try<br />&nbsp;&nbsp;&nbsp; aADOQuery.ExecSQL;<br />&nbsp;&nbsp;&nbsp; Result := true;<br />&nbsp; except<br />&nbsp;&nbsp;&nbsp; Result := false;<br />&nbsp;&nbsp;&nbsp; exit;<br />&nbsp; end;<br />finally<br />&nbsp; aADOQuery.Free;<br />end;<br />end;</p>
<p>function RestoreSQLDataBase(connstr_sql, DatabaseName, Restore_FileName: string): Boolean;<br />var //数据库恢复函数，estore_FileName以前备份的数据库文件<br />aADOQuery: TADOQuery;<br />begin<br />try<br />&nbsp; aADOQuery := TADOQuery.Create(nil);<br />&nbsp; aADOQuery.Close; //恢复数据库不能打开数据库，要打开系统数据库master，把连接字符串如adoconnetion的connectionstring中的数据库名称换成&quot;master&quot;数据库<br />&nbsp; aADOQuery.ConnectionString := repl_substr(DatabaseName, 'master', connstr_sql);<br />&nbsp; aADOQuery.SQL.Clear;<br />&nbsp; aADOQuery.SQL.Add('RESTORE DATABASE ' + DatabaseName + ' from disk = ' + '''' + Restore_FileName + '''');<br />&nbsp; try<br />&nbsp;&nbsp;&nbsp; aADOQuery.ExecSQL;<br />&nbsp;&nbsp;&nbsp; Result := true;<br />&nbsp; except<br />&nbsp;&nbsp;&nbsp; Result := false;<br />&nbsp;&nbsp;&nbsp; exit;<br />&nbsp; end;<br />finally<br />&nbsp; aADOQuery.Free;<br />end;<br />end;<br />end. </p>
<p><br />2003-11-25 13:17:15&nbsp;&nbsp; 不用控件，通过ADO对象连接sqlserver数据库关键词:ADO连接sqlserver数据库 </p>
<p>uses<br />Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs, StdCtrls, ExtCtrls,comobj, Db, ADODB;</p>
<p>//要伸明comobj 下面为连接代码:</p>
<p>var<br />adoc,ador:variant;<br />begin<br />adoc:=createoleobject('adodb.connection');<br />adoc.open('Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;Initial Catalog=customer;Data Source=BERN');<br />ador:=createoleobject('adodb.recordset');<br />ador.activeconnection:=adoc;<br />ador.CursorType:=ctDynamic;<br />ador.open('select * from t_customer',adoc);&nbsp;&nbsp; <br />end; </p>
<p><br />2003-11-25 13:28:58&nbsp;&nbsp; 存取JPEG文件到SQLSERVER数据库【王大川(WDCZZH)】【关键词】：JPEG图片图像数据库 <br />&nbsp; 最近在CSDN上看到两篇关于《DELPHI中存取JPEG文件到SQLSERVER》中的文章之后,觉得其中讲述的方法虽然有可取之处,但颇费时,我这里有更简单的操作方法，而且安全可靠,不敢一人独享,愿发布出来与大家共享。在Delphi7.0+Win2000+SqlServer 2000中测试通过，运行良好，现将思路、源码公开如下： </p>
<p>【解决思路】：<br />1、 关键在于将打开的JPEG文件动态转换为Tbitmap对象并显示在Timage对象中；<br />2、 将显示的图片提交到数据库中。</p>
<p>本例中在SQLSERVER2000中建立了一个试例表：exam(xm char(10),photo image)；<br />程序源代码：</p>
<p>unit SavePic;</p>
<p>interface</p>
<p>uses<br />Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs, ExtDlgs, ExtCtrls, DBCtrls, Grids, DBGrids, DB, ADODB, Buttons, StdCtrls,Jpeg;</p>
<p>type<br />TForm1 = class(TForm)<br />&nbsp; SpeedButton1: TSpeedButton;<br />&nbsp; ADOConnection1: TADOConnection;<br />&nbsp; Table1: TADOTable;<br />&nbsp; DataSource1: TDataSource;<br />&nbsp; DBGrid1: TDBGrid;<br />&nbsp; DBImage1: TDBImage;<br />&nbsp; Image1: TImage;<br />&nbsp; SpeedButton2: TSpeedButton;<br />&nbsp; OpenPictureDialog1: TOpenPictureDialog;<br />&nbsp; Label1: TLabel;<br />&nbsp; Label2: TLabel;<br />&nbsp; Edit1: TEdit;<br />&nbsp; SpeedButton3: TSpeedButton;<br />&nbsp; procedure SpeedButton2Click(Sender: TObject);<br />&nbsp; procedure SpeedButton1Click(Sender: TObject);<br />&nbsp; procedure SpeedButton3Click(Sender: TObject);<br />private<br />&nbsp; { Private declarations }<br />public<br />&nbsp; { Public declarations }<br />end;</p>
<p>var<br />Form1: TForm1;</p>
<p>implementation</p>
<p>{$R *.dfm}</p>
<p>procedure TForm1.SpeedButton2Click(Sender: TObject);<br />var<br />bmp1:TBitmap;<br />jpg1:TJpegImage;<br />begin<br />OpenPictureDialog1.DefaultExt:=GraphicExtension(TJpegimage);<br />if OpenPictureDialog1.Execute then<br />begin<br />&nbsp; bmp1:=TBitmap.Create;<br />&nbsp; jpg1:=TJpegImage.Create;<br />&nbsp; try<br />&nbsp;&nbsp;&nbsp; jpg1.LoadFromFile(OpenPictureDialog1.FileName);<br />&nbsp;&nbsp;&nbsp; bmp1.Assign(jpg1);<br />&nbsp;&nbsp;&nbsp; Image1.Picture.Bitmap.Assign(bmp1);<br />&nbsp; finally<br />&nbsp;&nbsp;&nbsp; jpg1.Free;<br />&nbsp;&nbsp;&nbsp; bmp1.Free;<br />&nbsp; end;<br />end;<br />end;</p>
<p>procedure TForm1.SpeedButton1Click(Sender: TObject);<br />begin<br />table1.Open;<br />table1.insert;<br />table1.fieldbyname('xm').asstring:=Edit1.Text;<br />table1.FieldByName('photo').Assign(Image1.Picture); <br />tabl<br />&nbsp; </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br />&nbsp;</p>
<p>&nbsp;</p>
<p><br />&nbsp;</p><p class="right articalinfo">发表于 @ <a href="http://blog.csdn.net/guolei0451/archive/2006/09/13/1217574.aspx" Title = "permalink">2006年09月13日 13:11:00</a>&#124;<a href="http://blog.csdn.net/guolei0451/archive/2006/09/13/1217574.aspx#FeedBack" Title = "评论">评论(<span id="FeedbackCount_1217574">loading...</span><script type="text/javascript">AddFeedbackCountStack("1217574")</script>)</a>&#124;<a href="http://writeblog.csdn.net/PostEdit.aspx?entryId=1217574" Title = "编辑">编辑</a></p>
    <span id="Post.ascx_ViewPost_PreviousAndNextEntriesDown"><h3><a href="http://blog.csdn.net/guolei0451/archive/2006/09/13/1217544.aspx">旧一篇:&nbsp;C#.Net网络程序开发-Socket篇 </a></h3></span>

    <script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script>
    <script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shCore.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushCSharp.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushXml.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushCpp.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushCss.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushDelphi.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushJava.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushJScript.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushPhp.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushPython.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushRuby.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushSql.js"></script>
<script language="javascript" src="http://hi.images.csdn.net/js/syntaxhighlighter/scripts/shBrushVb.js"></script>

<script language="javascript">
//window.onload = function(){
dp.SyntaxHighlighter.ClipboardSwf = 'http://hi.images.csdn.net/flash/syntaxhighlighter/clipboard.swf';
dp.SyntaxHighlighter.HighlightAll('code');
//}
</script>
</div>


        <script type="text/javascript">LoadFeedbackCount();</script>
        

<!-- tag ad for news template -->
<script language="javascript">
ad_width=468;
ad_height=60;
adcss=2;
unionuser=19;
tags='';
ad_type='j';
count=2;
</script>
<script language="javascript" src="http://tagegg.csdn.net/showads.js" type="text/javascript"></script>

<div id="Post.ascx_TagAd_palTagAd">
	
    <div class="tagadfornews" id="csdn_tag_adstyle"></div>

</div>
<script language="javascript" src="http://blog.csdn.net/js/show_blog_tagad.js" type="text/javascript"></script>
<link rel="stylesheet" href="http://blog.csdn.net/css/tag_blog.css" type="text/css" media="all" /> 
    </div>
    <div class="commentslist">
        <span id="Anthem_Post.ascx_Comments_ltlComments__"><span id="Post.ascx_Comments_ltlComments"><div id="commentslist"><h3>评论</h3><dl class="question"><dt><a title="permalink: 回复:本人总结的SQL用法" href="http://blog.csdn.net/guolei0451/archive/2006/09/13/1217574.aspx#552112">#</a><a name="552112"></a><a href="http://blog.csdn.net" target="_blank" rel="nofollow">zhoufoxcn</a>&nbsp;发表于2007-04-11 16:40:55&nbsp;&nbsp;IP: 61.134.233.*</dt><dd>挺好的，唯一就是挺长，收藏了慢慢看。</dd></dl></div></span></span>

    </div>
    <div class="spacecommment">
        <div id="Anthem_Post.ascx_PostComment_CommentUpdatePanel__"><div id="Post.ascx_PostComment_CommentUpdatePanel">
	
    <fieldset>
        <legend>发表评论</legend>
        <ul>
            <li>姓&nbsp;&nbsp;&nbsp;名：<input name="Post.ascx:PostComment:tbName" type="text" value="jackfor001" maxlength="32" id="Post.ascx_PostComment_tbName" disabled="disabled" Size="40" /><span controltovalidate="Post.ascx_PostComment_tbName" errormessage="请输入名字" id="Post.ascx_PostComment_RequiredFieldValidator2" evaluationfunction="RequiredFieldValidatorEvaluateIsValid" initialvalue="" style="color:Red;visibility:hidden;">请输入名字</span></li>
            <li>主&nbsp;&nbsp;&nbsp;页：<input name="Post.ascx:PostComment:tbUrl" type="text" maxlength="256" id="Post.ascx_PostComment_tbUrl" Size="40" /></li>
            <li>
                <div id="Post.ascx_PostComment_AntiBotImageRegion">
		
                    校验码：
                    <input name="Post.ascx:PostComment:tbAntiBotImage" type="text" id="Post.ascx_PostComment_tbAntiBotImage" style="width:75px;" />
                    <span display="Dynamic" id="Post.ascx_PostComment_valAntiBotImage" evaluationfunction="CustomValidatorEvaluateIsValid" style="color:Red;display:none;">检验码无效!</span>
                    <span id="Anthem_Post.ascx_PostComment_imgAntiBotImage__"><img id="Post.ascx_PostComment_imgAntiBotImage" src="/AntiBotImage.aspx?abi=7680&amp;id=1217574" alt="" align="absmiddle" border="0" /></span>
                    <span id="Anthem_Post.ascx_PostComment_lbCreateAntiBotImage__"><a onclick="javascript:Anthem_FireCallBackEvent(this,event,'Post.ascx:PostComment:lbCreateAntiBotImage','',false,'','','',true,null,null,null,true,true);return false;" id="Post.ascx_PostComment_lbCreateAntiBotImage" href="javascript:__doPostBack('Post.ascx$PostComment$lbCreateAntiBotImage','')">看不清,换一张</a></span>
	</div>
            </li>
        </ul>
        <span controltovalidate="Post.ascx_PostComment_tbComment" errormessage="请输入评论" id="Post.ascx_PostComment_RequiredFieldValidator3" evaluationfunction="RequiredFieldValidatorEvaluateIsValid" initialvalue="" style="color:Red;visibility:hidden;">请输入评论</span><br />
        <textarea name="Post.ascx:PostComment:tbComment" rows="10" cols="50" id="Post.ascx_PostComment_tbComment"></textarea><br />
        <span id="Anthem_Post.ascx_PostComment_btnSubmit__"><input type="submit" name="Post.ascx:PostComment:btnSubmit" value="提交" onclick="javascript:Anthem_FireCallBackEvent(this,event,'Post.ascx:PostComment:btnSubmit','',true,'','','正在处理...',false,null,null,null,true,true);return false;WebForm_DoPostBackWithOptions(new WebForm_PostBackOptions(&quot;Post.ascx:PostComment:btnSubmit&quot;, &quot;&quot;, true, &quot;&quot;, &quot;&quot;, false, false))" language="javascript" id="Post.ascx_PostComment_btnSubmit" /></span>
        <br />
        <span id="Post.ascx_PostComment_Message" style="color:Red;"></span>
    </fieldset>

</div></div>

    </div>
</div>
 
            
        </div>
    </div>
    
    <div id="pubfooter">
        
<dl>
    <dt></dt>
    <dd>
        Csdn Blog version 3.1a</dd>
    <dd>
        Copyright &copy;
        guolei
    </dd>
</dl>

        <script type="text/javascript" src="http://www.csdn.net/common/counter.js"></script>
    </div>
</div>

        
<script type="text/javascript">
<!--
var Page_Validators =  new Array(document.getElementById("Post.ascx_PostComment_RequiredFieldValidator2"), document.getElementById("Post.ascx_PostComment_valAntiBotImage"), document.getElementById("Post.ascx_PostComment_RequiredFieldValidator3"));
// -->
</script>


<script type="text/javascript">
<!--
var Page_ValidationActive = false;
if (typeof(ValidatorOnLoad) == "function") {
    ValidatorOnLoad();
}

function ValidatorOnSubmit() {
    if (Page_ValidationActive) {
        return ValidatorCommonOnSubmit();
    }
    else {
        return true;
    }
}
// -->
</script>
        </form>
        <script type="text/javascript" language="javascript">CJB.AsyncTooltip.initAsync();</script>
        
    </div>
</body>
</html>
